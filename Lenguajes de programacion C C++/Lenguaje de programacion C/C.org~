#+STARTUP: content

* Lenguaje C [9/12]
** DONE Conceptos Básicos(Basic concepts) [6/6]
   CLOSED: [2023-09-17 dom. 22:12]
*** DONE Capturando datos de la entrada estandar
	CLOSED: [2023-09-17 dom. 21:09]
	- la funcion *scanf* (scan format)  sirve para recibir datos desde la consola 
	- Esta funcion sigue tres reglas
		1. Retorna el numero de objetos que lees.
		2. Si la información es para un tipo de dato primitivo con *int* , *char* ect.. ,
		  debes poner el simbolo *&* de direccion y despues el nombre de la variable.
		3. Si usas *scanf* para leer una cadena de caracteres en un arreglo no uses & con el arreglo.
 #+BEGIN_SRC C

   #include<stdio.h>

   int main(){
	   char array[20];
	   int edad;
	   double dir;
	   scanf("%d",&edad); // La funcion scanf no recibe texto solo 
						  // el indicador de formato a almacenar
						  // en este caso %d por ser un int
   }

 #+END_SRC

*** DONE Commentario(Comments)
	CLOSED: [2023-09-17 dom. 20:52]
 #+BEGIN_SRC C
	// Estos es un comentario de una linea
	/*
		Este comentario 
		es de multiples 
		lineas		
	*/
 #+END_SRC

*** DONE El preprosesador (The Preprocessor and The #include statement)
	CLOSED: [2023-09-17 dom. 21:09]
- El preprosesador es una caracteristica unica de C y C++ permite llamar bibliotecas, definir constantes, crear macros ect..
- Las funcionalidades del preprosesador se declaran comenzando con el simbolo #.
- Usualmente se declara al principio de los archivos .c o .h, pero pueden declararse en cualquier parte del archivo. 
- El preprocesador se ejecuta antes de que el codigo declarado en c se ejecute en una parte del proceso de compilacion llamado **preprosado**:
#+BEGIN_SRC C
  #include <stdio.h> //Directiva del Preprosesador
	
  int main(){
	  return 0;
  };
#+END_SRC

- Los archivos cabecera *header(.h) definen la informacion de algunas de las funciones que vamos a utilizar.
- En el caso de <stdio.h> define la funcionalidades de entrada y salida de datos del sistema que necesita el compilador para funcionar, ejemplo es la funcion printf(). stdio significa "*standart input output*" 
- Los archivos cabecera especifica la infomacion que el compilador usa para integrar cualquier informacion de una funcion dentro del programa.
- Los nombres de los headers son case sensitive significa que deben escribirse con cuidado, ya que sino daria problemas al importarlos en el programa durante el preprocesado.

- Hay 2 formas de incluir un archivo header en un programa
#+BEGIN_SRC C

  /*
	  Usando llaves angulares le decimos al sistema que busque dentro
	  del sistema de directorio estandar
  ,*/		
  #include <stdio.h>   

  /*
	  Usando las doble comilla "milib.h"
	  Les decimos al compilador que busque primero en el directorio actual
  ,*/
  #include "mylib.h"

#+END_SRC

- Las directivas del preprocesador *#ifndef* y *#define* protegen contra la inclusion de multiples archivos headers.
- En los [[Header]] puedes declarar varios tipo de elementos y el codigo va en los archivos .c
  - En los headers se declara informacion de funciones que provienen de dicho archivo
	Para usar la funcion *printf()* se debe usar *stdio.h* (standard input output). 
  - Los headers se deben definer en minuscula *siempre*.
	
*** DONE Mostrando salidas de datos (Displaying Output)
	CLOSED: [2023-09-17 dom. 22:10]
  - La funcion *printf* convierte todos los tipo básicos
	en texto. Digase float, int, bool, double ect.
#+BEGIN_SRC C
	#include <stdio.h>

 int main(){
	printf("Hola mundo");
	return 0;
  }

#+END_SRC

*** DONE Leyendo entradas desde la terminal(Reading input from the terminal)
	CLOSED: [2023-09-17 dom. 22:10]
  - Para leer entradas desde la terminal se usa funciones como *scanf* para leer
	las teclas presionadas.
  - Cuando tecleas el entero 2014 no entras un solo digito sino 4 por separado.
	"2","0","1","4"
  - Scanf usa 3 reglas para su uso:
	- Retorna el numero de objetos que lee exitosamente.
	- Si se usa un valor de un tipo de datos básico se usa el simbolo *&* .
	- Si se usa el scanf para leer dentro de un arreglo no se usa el simbolo *&* .
	- Scanf espera a que se precione enter para continuar con el programa.
	- Se debe especificar el formato en cuanto a longitud y de teclas.
 #+BEGIN_SRC C

   //Ejemplo no.1
	#include <stdio.h>

	int main(){
		char str[100];
		int i;  
		printf("Inserte un valor:");
		scanf("%s %d",str,&i);

		printf("Usted insertó el valor %s %d",str,i);
		return 0;

	  /*
		double x;
		scanf("%lf",&x);
	  */

	}



 #+END_SRC

*** DONE Expresiones y declaraciones (Expresions and Statement) 
	CLOSED: [2023-09-17 dom. 22:10]
	- Las declaraciones o *statement* son los pasos basicos de un programa en C. Muchas declaraciones estan construidas a partir de expresiones.
	- Las declaraciones son los bloques de un programa.
	- Un programa es una series de declaraciones con sintasis especial que teminan con un _punto y coma_.
	  #+BEGIN_SRC C
		                   //Los siguientes son ejemplos de declaraciones
		int alejandro;     // Declaración (Declaration Statement) 
		alejandro = 5;     // Asignación  (Assignment)
		printf("Alex");    // Llamada de función (Function call statement)
		while(alejandro < 20) alejandro += 1; 
						   // Declaración structurada (Structure Statement)
		return 0;          // Declaración de retorno (return statement)
						   // C considera que una expresion puede ser una declaracion si se le 
						   // adiciona un ; son perfectamente válido en c.

		8; 3 - 4;          // Expresión  (Expression Statements)
	  #+END_SRC

	- Las *declaracion compuestas* se encuentran dentro de bloques de codigo

	  #+BEGIN_SRC C

		int index = 0;           
		while(index < 10){       //Declaracion estructurada
			printf("Hola");      
			index = index + 1;
		}

	  #+END_SRC

	- Una expresion o "*expression*" consiste en una combination de operandos y operadores 
		1. Los operandos son sobre los que un operador trabaja ej: 2 + 4 los operando son 2 y 4 y el operador es +
		2. Los operandos pueden ser constantes, variables, o combinaciones de los 2 tipos.
		3. Todas las expresiones tienen un valor.
		4. Ejemplos de expresion:

	#+BEGIN_SRC C
		-6 
		4 + 21
		a * (b+ d/c) /20
		q = 5*2
		x = ++q % 3
		q > 3    

	#+END_SRC

** DONE Variables y tipos de datos (Variables y Data Types) [7/7]
   CLOSED: [2023-09-19 mar. 13:55]
*** DONE Resumen (Overview)
	CLOSED: [2023-09-19 mar. 13:47]
   - Los sistemas de computo usan memoria ram para leer y ejecutar
	 los programas. Las variables y constantes usan espacio de memoria
	 las cuales se les asigno un nombre y un tipo que cambiara segun corra
	 el programa.
   - Existen varias formas de declarar una variable pero debe comenzar con:
	 - Letras o Guión bajo ( *_* ) seguido por cualquier combinacion de caracteres o digitos.
   - Las variables no se pueden declarar con caracteres como:
	 - $ u otros como $#%^&*( .
	 - No se puede usar espacios entre nombre de variables *my flag*
	 - numeros delante de las variables
	 - Palabras reservadas como *int*, *char*, *struct*
   - Usar palabras con significado en la declaracion de variables ayuda
	 a documentar y debuggear mejor el código.
   - Para usar una variable en *C* se debe declarar primero antes de usar
	 la declaración está compuesta por *tipo-dato* *nombre-variable*. Como se puede
	 ver en el ejemplo a continuación.
   - Se puede declarar mas de una variable del mismo tipo en la misma linea
	 solo separado por coma.  
   - Se inicializa la variable asignandole un valor con el simbolo *=* en la
	 misma declaración de esta.
   - No se aconseja declarar e inicializar solo una variable en una linea con
	 varias variables, es una mala forma de hacerlo.   
   #+BEGIN_SRC C

   //Las siguentes formas son nombres de variables correctas
	   char Jason,iniciales = 'A';
	   Jason = 'a';

	   int Jason2;

	   int i;
	   double j5x7;
	   float j5x7;
	   char *my_data;
	   struct name _anotherVariable;

	   int age,edad = 38; //Puede provocar problemas despues porque resulta confunso
					   //En algunos casos

   #+END_SRC
*** DONE Tipos de datos básicos (Basic Data Types)
	CLOSED: [2023-09-19 mar. 13:47]
   - En C existen varios tipos de datos primitivos, la diferencia entre estos es:
	la cantidad de memoria a almacenar*
   #+BEGIN_SRC C
	   int           /* enteros          (1,2,-10)*/
	   float         /* punto flotantes  (10.0,23.33 ,-13.654)*/
	   double
	   char
	   _Bool
   #+END_SRC

   1. Los enteros *int* almacenan números decimales completos
   2. Se puede almacenar los número positivos y negativos en los *int*
   3. Los enteros almacenan ademas números hexadecimales 
   4. Si se asigna un cero y despues una x seguido por numero y caracteres de 
		la A a la F en minuscula o mayuscula, se considerara un hexadecimal.
   5. Los *int* contienen tres _adjetivos_ que convinados con el tipo int pueden darle
	   un rango mas amplio de valor a los enteros.
   6. Los adjetivos tambien se pueden usar con tipo de variables.
   #+BEGIN_SRC C

	 int value        		 = 10;       // Declaracion de variables y asignacion de datos.
	 int rgbColor     		 = 0x00FADB;
	 short int value2 		 = 10;
	 short value3     		 = 23;       // Ocupa menos espacio que un int.
	 signed value4           = 12;       // Desde los limites negativos a los positivos.
	 unsigned int values2    = 12;       // Para numeros positivos solamente.
	 long value5             = 23;
	 long long value6        = 4567;
	 signed long long values = 86532;
	 long float valuex;
	 long double valued;

   #+END_SRC

   1. Los flotantes *float* almacenan números punto flotantes ( números que contienen espacios decimales )
   2. Los valores 3., 125.8 y -.0001 son ejemplo de constantes punto flotantes que pueden ser asignado una variable.
   3. Los valores flotantes pueden ser expresados en notacion científica 
	  1.7e4 es un numero punto flotante expresado in esta notacion y representa el valor 1.7 x 10 a la potencia de 4.	
   4. Los float constantes se inicializan como double en la maquinas de  64 bits.
   5. Para declarar que son de tipo *float* constantes se les pone una f al final del numero.

   #+BEGIN_SRC C

	 float value = 1.01245; 
	 float value2 = 1.56f;

   #+END_SRC

   1. Los *double* son del mismo tipo que los flotantes pero con mas precisión.
   2. Se usa cuando el rango de precision de las variables floats no son suficientes.
   3. Puede almacenar el doble de digitos significativos.
   4. La mayorias de las computadores representan doubles usando 64 bits
   5. Los *_Bool* son los tipos de datos mas pequeños, para almacenar solo 0 u 1,
	  estos representan el estado binario, apagado o encendido, si o no,
	  verdadero o falso. El valor 0 indica el valor falso, y 1 indica el valor verdadero.
	  Para usar las palabras reservadas *true* o *false* se usa la biblioteca *stdbool.h*
 
   6. Los *long* pueden ser usados para almacenar grandes cantidades.
   7. Las variables constantes *long* se forman opcionalmente adicionando una L en
	  mayuscula o minuscula al final de una constante de *int* 
   8. Lo mismo es valido para los *double*. 

   #+BEGIN_SRC C

	 long int val = 131071100L;
	 long double us_deficit_2017 = 1.234e+7L;

   #+END_SRC
*** DONE Enumerados y Characteres (Enums and Chars)
	CLOSED: [2023-09-19 mar. 13:48]
   - Los *enum* son tipos de datos que permiten al programador definir una variable y
	 especificar los valores que se puede almacenar en esta.
   #+BEGIN_SRC C
	 enum myColors {    //Creacion de enum
		 white,
		 black,                 
		 yellow,                  
	 };
	 enum myColors mis_colores,tus_colores; 
		 //Inicializacion de enums	
		 //mis_colores y tus_colores							  

   #+END_SRC

   - Los enumerados se inicializan con valores o se pueden quedar sin estos.
	 Por defecto los valores se inicializan en 0 si no tienen valor asignado como el ejemplo anterior.
	 Los valores que toman en el enum se incrementan al ultimo valor asignado.
   - En el proximo ejemplo vemos como se puede inicializar de diferentes formas.

   #+BEGIN_SRC C
	   enum Colores {
		   black = 0,
		   white = 2,
		   yellow,
		   blue,
		   green = 10,
		   red,
		   brown	
	   }
	       // En este caso de declaracion los valores
		   // yellow = 3 y blue = 4, porque continuan la cadena del 
		   // enum sin asignacion de valores despues de haber creado white
		   // con valor 2. Pasa lo mismo con red y brown  
   #+END_SRC
  
	 - Los *char* representan un solo valor se representan con las comillas simples ''
	 - Se pueden asignar numeros a los caracteres y estos seran combertidos en ascii por el compilador.
	 - Se puede usar escape de caracteres de para realizar ciertas acciones.
	 #+BEGIN_SRC C

		 char iniciales = 'a';
		 char iniciales2 = 65; // Es a, pero no se aconseja user esta asignación
							 // porque no es facilmente referenciable
		 char escape_character = '\n';
	 #+END_SRC
	 - En la siguiente tabla se muestran las secuencias usadas por escapes de caracteres
	   |-----------+-------------------------------------------------------|
	   | *Secuencia* | *Significado*                                           |
	   |-----------+-------------------------------------------------------|
	   | \a        | Alerta(ANSI C)                                        |
	   | \b        | Backspace                                             |
	   | \f        | Form Feed                                             |
	   | \n        | Nueva linea                                           |
	   | \r        | Retorno de Linea                                      |
	   | \t        | Tab horizontal                                        |
	   | \v        | Tab vertical                                          |
	   | \\        | Backslash                                             |
	   | \'        | Comillas simple                                       |
	   | \"        | Comillas multiples                                    |
	   | \?        | Signo de interrogación                                |
	   | \0oo      | Valor octal (o representa el digito octal)            |
	   | \xhh      | Valor Hexadecimal (h representa el valor hexadecimal) |
	   |-----------+-------------------------------------------------------|

	 
*** DONE Especificadores de formato(Format specifiers)
	CLOSED: [2023-09-19 mar. 13:48]
   - Los especificadores de formato sirven para dar formato de salida a las variables que se pasan a funciones como printf.
   #+BEGIN_SRC C

	   int edad = 30;
	   scanf("Inserte su edad aqui %d",&edad);
	   // Este es un ejemplo de captura de datos de pantalla en C

   #+END_SRC
   Los parametros siguientes se usan para capturar los diferentes 
   formatos en C:

   |------------------------+----------------------------------------+------------------------------------|
   | Tipo de dato           | Especificación de conversión de printf | Especificación de conversión scanf |
   |------------------------+----------------------------------------+------------------------------------|
   | char                   | %c                                     | %c                                 |
   | _Bool                  | %i %u                                  | %i %u                              |
   | int                    | %d                                     | %d                                 |
   | string                 | %s                                     | %s                                 |
   | float                  | %f %e %g %a                            | %f                                 |
   | double                 | %f %e %g %a                            | %lf                                |
   | long double            | %Lf $Le %Lg                            | %Lf                                |
   | long int               | %ld %lx %li %lo                        | %ld                                |
   | short                  | %hd                                    | %hd                                |
   | int--bool              | %i                                     |                                    |
   | short int              | %hi %hx %ho                            |                                    |
   | pointers               | %u %p                                  |                                    |
   | unsigned short int     | %hu %hx %ho                            |                                    |
   | unsigned long int      | %lu %lx %lo                            | %lu                                |
   | unsigned int           | %u %x %o                               | %u                                 |
   | long long int          | %lli %llx %llo                         | %lu                                |
   | unsigned long long int | %llu %llx %llo %zd                     | %lu                                |
   | sizeof(dato primitivo) | %u                                     |                                    |
   | size_t                 | %zu                                    | %zu                                |
   |------------------------+----------------------------------------+------------------------------------|
	
	 - Para saber la longitud con strlen() 		
	 - Los especificadores de formato permite adicionarles un ancho al formato del valor ej:
	 - Los valores se redondean por el compilador.
	  #+BEGIN_SRC C

		  float value = 3.999230;
		  int val     = 4;
		  printf("%.2f",value);   //Este caso imprime hasta 3.99 osea dos
								  //valores despues de la coma
		  printf("%.5f",value);   //Aqui se imprime hasta 5 valores despues
								  //de la coma (3.99923).    
		  printf("Hola %4d",val); //Aqui se muestra valores de tipo decimal
								  // con 4 espacios despues de Hola ya que el valor
								  // despues de % dice la cantidad de espacios posterior
								  // a la cadena previa
	 #+END_SRC
  
	 - Ejemplo del video
	 #+BEGIN_SRC C
	 #include <stdio.h>

		 int main(void){
			 int    integerVar   = 100;
			 float  floatingVar  = 331.79356;
			 double doubleVar    = 8.44e+11;
			 char   charVar      = 'W';
			 _Bool  boolVar      = 0;

			 print("integerVar = %i\n",integerVar);
			 print("floatingVar = %f\n",floatingVar);
			 print("doubleVar = %e\n",doubleVar);
			 print("doubleVar = %g\n",doubleVar);
			 print("charVar = %c\n",charVar);
			 print("boolVar = %i\n",boolVar);

			 printf("floatingVar %.2f",floatingVar)
			 // Solo mostrará 331.79 porque el .2f le dice que muestre hasta la segunda
			 // posicion despues de la coma si se quisiera mostrar mas por ejemplo 331.7956 
			 // seria .4f

			 return 0;
		 }
	 #+END_SRC
	 |------------------------+---------------------------------+-------------------|
	 | Tipo                   | Constantes                      | Caracteres printf |
	 |------------------------+---------------------------------+-------------------|
	 | char                   | 'a', '\n'                       | %c                |
	 | _Bool                  | 0,1                             | %i, %u            |
	 | short int              | --                              | %hi, %hx, %ho     |
	 | unsigned short int     | --                              | %hu, %hx, %ho     |
	 | int                    | 12,-97,0xFFE0,0177              | %i, %x, %o        |
	 | unsigned int           | 12u, 100u,0xFFu                 | %u, %x, %o        |
	 | long int               | 12L,-2001,0xffffL               | %li, %lx, %lo     |
	 | unsigned long int      | 12UL,100ul,0xffeeUL             | %lu, %lx, %lo     |
	 | long long int          | 0xe5e5e5e5LL, 500ll             | %lli, %llx, %llo  |
	 | unsigned long long int | 12ull, 0xffeeul                 | %llu, %llx, %llo  |
	 | float                  | 12.34f, 3.le-5f,0x1.5p10,0x1P-1 | %f, %e, %g, %a    |
	 | double                 | 12.34f, 3.le-5,0x.1p3,          | %f, %e, %g, %a    |
	 | long double            | 12.341,3.1e-51                  | %Lf, %Lx, %Lg     |
	 |------------------------+---------------------------------+-------------------|
	 - Esta tabla se tomo como ejemplo del libro de *"Programming in C"* Kochan
*** DONE Argumentos de linea de commandos (Command line arguments)
	CLOSED: [2023-09-19 mar. 13:48]
   - Los argumentos de lineas de commando son los datos que se les pasa a una funcion para realizar tareas de con los datos que se pasan.
   #+BEGIN_SRC C
	 int main(int argc,char *argv[]){
		 //argc son el total de argumentos que se les pasa
		 // a la funcion

		 //argv es la lista de vectores que se le pasa como parametro.
		 //El primer parametro que recibe es la ruta de la funcion.

		   int numberOfArgument = argc;
		   char *argument1      = argv[0]; 
		   char *argument2      = argv[1]; 

		   printf("Number of Arguments: %d\n",numberOfargument);
		   printf("Argument Number 1 is the program name: %s\n",argument1);
		   printf("Argument Number 2 is the command line argument: %s\n",argument2);

		   return 0;
	 }
   #+END_SRC
*** DONE *Desafío* Imprimir el área de un rectangulo(Challenge Print area of a rectangle)
	CLOSED: [2023-09-19 mar. 13:48]
   - Crea un programa que muetre el área de un rectangulo y su perimetro
	 el programa debe contener 4 variable de tipo *double* (ancho, alto, área, perimetro)
   - Se deben usar los operadores de multiplicación y suma (* +)
   - EL perimetro se calcula sumando ancho y alto y multiplicando por 2
   - El área se calcula multiplicando las variables ancho y alto 
   #+BEGIN_SRC C
	 // Mi solución	
	 #include <stdio.h>	

	  int main(){
		 double width  = 0.0;
		 double height = 0.0;

		 printf("Describa la altura de el triangulo: ");
		 scanf("%f\n",height);
		 printf("Describa el ancho de el triangulo: ");
		 scanf("%f",width);

		 print("El área del triángulo es: \n",width * height);
		 print("El perimetro del triángulo es: \n",(width + height) * 2);
		 return 0;
	  } 

	 // Solución del curso
	 #include <stdio.h>	
	 #include <stdlib.h>	

	  int main(int argc,char *argv[]){
							// Atoi convierte de char a entero
		 double width     = atoi(argv[0]);
		 double height    = atoi(argv[1]);
		 double area      = 0.0;
		 double perimeter = 0.0;

		 area       = width * height;
		 perimeter  = (width + height) * 2.0;

		 printf("Width is: %.2f \n",width);
		 printf("Heigth is: %.2f \n",height);
		 printf("Area of rectangle: %.2f \n",area);
		 printf("Perimeter of rectangle: %.2f \n",area);

		 return 0;

	  } 

   #+END_SRC
*** DONE *Desafío* Crear y usar un tipo de enumerado(Challenge Create and use an enum type)
	CLOSED: [2023-09-19 mar. 13:55]
   - Crea un enumerado de nombre Company con los valores:
	- *GOOGLE*
	- *FACEBOOK*
	- *XEROX*
	- *YAHOO*
	- *EBAY*
	- *MICROSOFT*
   - La salida correcta del programa debe ser *XEROX*, *GOOGLE*, *EBAY* con 2, 0, 4 cada uno respectivamente
   - Usa los tipo de datos mencionados, inicializa las variables de los enumerados 
     y imprime la salida de caracteres y el símbolo de escape de caracteres.
   #+BEGIN_SRC C
	//Mi solucion y la del curso.
	 #include <stdio.h>

	 int main(void){
		enum Company {
			GOOGLE,
			FACEBOOK,
			XEROX,
			YAHOO,
			EBAY,
			MICROSOFT,
		};
		enum Company xerox = XEROX;
		enum Company google = GOOGLE;
		enum Company ebay = EBAY;
		printf("EL valor de la compania xerox es %d",xerox);

		printf("EL valor de la compania google es %d",google);
		printf("EL valor de la compania ebay es %d",ebay);
		
		return 0;
	 }


   #+END_SRC	
** DONE Operadores(Operators) [7/7]
   CLOSED: [2023-09-20 mié. 21:22]
*** DONE Resumen (Overview) 
	CLOSED: [2023-09-19 mar. 15:09]
   - Los operadores son funciones que usan un nombre simbólico:
	 1. Realizan funciones logicas y matematicas
	 2. Los operadores estan definidos como en cualquier otro lenguage de programación
	 3. Un operador lógico a veces llamado *operador booleano* retorna un resultado
		basado en una o dos expresiones.
	 4. Un operador aritmetico toma dos operandos y realiza calculos con ellos.
	 5. Existen otros operadores como los de asignación, relacionales(<,>,!=), bitwise(<<, >>,negacion tilde de la eñe) 
   *Expressions and Statements* (Espresiones y declaraciones )
	- Las declaraciones forman los pasos básicos de un programa muchas declaraciones 
	  son expresiones.
    - Una expresion consiste en una combinación de operadores y operandos
	  1. Los operandos son sobre lo que el operador opera.
	  2. Operandos pueden ser constantes, variables, o combinaciones de ambos.
	  3. Cada expresion tiene un valor.	
	#+BEGIN_SRC C
	  // Ejemplo de expresiones 
	  -6
	  4 + 21
	  a*(b + c/d)/20 
	  q = 5 * 2
	  x = ++q % 3

	#+END_SRC
	
	- Las declaraciones son los bloques de un programa
	  1. Un programa tiene una serie de declaraciones que terminan en(*;*)
		 (declaración simple).
	  2. Es una instrucción completa a a la computadora.
	  3. *C* Considera que una expresion es un declaracion si se les escribe al final un (*;*).
		 Por lo que: *8;* y *3-4;* son ejemplo válidos.

 #+BEGIN_SRC C
	/*Declaracion*/                       int jason;
	/*Declaracion de asignacion*/         jason = 5;
	/*Declaracion de llamada de función*/ printf("Jason");
	/*Declaracion estructurada*/ 		  while (Jason < 20 ) Jason = Jason + 1;
	/*Declaracion de retorno*/ 			  return 0;
 #+END_SRC

 #+BEGIN_SRC C
   // Dos o mas declaraciones agrupados juntos entre parantesis enserrandolos 
   // en un (bloque) se considera una DECLARACION COMPUESTAS

   int index = 0;
   while(index < 0){
		printf("Hello");
		index = index + 1;
	}

 #+END_SRC
*** DONE Operadores básicos(Basic Operators)
	CLOSED: [2023-09-20 mié. 12:47]
	- Los operadores básicos son los siguientes:
	  - Los operadores aritmeticos es una funcion matemática que toma dos operandos 
		y realiza calculos con ellos ( *** *+* */* *-* )
	  - Los operadores lógicos son llamados operadores booleanos los cuales retorna 
		un resultado de dos expresiones.
	  - El operador de asignación asigna los valores de la derecha a las variables de la izquierda.
	  - EL operador relacional compara las variables entre ellas. 
	  
	  Como ejemplo para las siguientes tablas tomemos los siguentes casos 
		- *A* = 10
		- *B* = 20

      *OPERADORES ARITMETICOS*
	  |------------+-----------------------------------------------+-------------|
	  | Operadores | Descripcion                                   | Example     |
	  |------------+-----------------------------------------------+-------------|
	  | +          | Adiciona dos operandos                        | A + B = 30  |
	  |------------+-----------------------------------------------+-------------|
	  | -          | Sustrae el segundo del primero                | A - B = -10 |
	  |------------+-----------------------------------------------+-------------|
	  | ***          | Multiplica ambos operandos                    | A * B = 200 |
	  |------------+-----------------------------------------------+-------------|
	  | */*          | Divide el numerador por el                    | B / A = 2   |
	  |            | denominador.                                  |             |
	  |------------+-----------------------------------------------+-------------|
	  | %          | El operador de modulo y de                    | B % A = 0   |
	  |            | despues de una division de entero.            |             |
	  |------------+-----------------------------------------------+-------------|
	  | ++         | Operador de incremento, aumenta el valor      | A++ = 11    |
	  |            | en uno.                                       |             |
	  |------------+-----------------------------------------------+-------------|
	  | --         | Operador de decremento, disminuye su valor en | A-- = 9     |
	  |            | uno.                                          |             |
	  |------------+-----------------------------------------------+-------------|

	  *OPERADORES LÓGICOS* 
	  |------------+-----------------------------------------------------------+---------------------|
	  | Operadores | Descripción                                               | Ejemplo             |
	  |------------+-----------------------------------------------------------+---------------------|
	  | &&         | LLamado operador logico _AND_. Si                           | ( A && b ) is false |
	  |            | ambos operandos son no cero, entonces                     |                     |
	  |            | las condiciones se vuelven verdadero.                     |                     |
	  |------------+-----------------------------------------------------------+---------------------|
	  | ||         | LLamado operador logico _OR_. Si cualquiera de los dos      | (A ||  B) is true    |
	  |            | operandos es no zero entonces las condiciones se vuelven  |                     |
	  |            | no zero. Por lo que las condiciones se vuelven verdaderos |                     |
	  |            |                                                           |                     |
	  |------------+-----------------------------------------------------------+---------------------|
	  | *!*          | Llamado el operador _NOT_. Es usado para revetir el estado  | !(A && B) is true   |
	  |            | lógico de sus operandos. si una condicion es falsa        |                     |
	  |            | se vuelve verdadera.                                      |                     |
	  |------------+-----------------------------------------------------------+---------------------|
	  
	  *OPERADORES DE ASIGNACION*
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | Operador | Descripcion                                                  | Ejemplo                             |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | *=*        | Operador de asignacion                                       | C = A + B Le asignara el resultado  |
	  |          |                                                              | de A + B a C                        |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | +=       | Adiciona el operador de asignacion                           | C += A es equivalente a C = C + A   |
	  |          | Adiciona el operando de la derecha con el de                 |                                     |
	  |          | la izquierda y el resultado se lo asigna al de la izquierda. |                                     |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | +=       | Adiciona el operador de subtracion                           | C -= A es equivalente a C = C - A   |
	  |          | Substrae el operando de la derecha con el de                 |                                     |
	  |          | la izquierda y el resultado se lo asigna al de la izquierda. |                                     |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | *=       | Adiciona el operador de multiplicacion                       | C *= A es equivalente a C = C * A   |
	  |          | Multiplica el operando de la derecha con el de               |                                     |
	  |          | la izquierda y el resultado se lo asigna al de la izquierda. |                                     |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | /=       | Adiciona el operador de division                             | C /= A es equivalente a C = C / A   |
	  |          | Divide el operando de la izquierda entre el de la derecha    |                                     |
	  |          | y el resultado se lo asigna al de la izquierda.              |                                     |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | %=       | Adiciona el operador de modulo                               | C %= A es equivalente a C = C % A   |
	  |          | Se aplica el modulo a la division y asigna el resultado a la |                                     |
	  |          | al operador de la izquierda                                  |                                     |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | <<=      | Left shift _AND_ operador de asignacion                        | C <<= 2 es equivalente a C = C << 2 |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | >>=      | Right shift _AND_ operador de asignacion                       | C >>= 2 es equivalente a C = C >> 2 |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | &=       | Bitwise _AND_ y operador de asignacion                         | C &= 2 es equivalente a C = C & 2   |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | ^=       | Bitwise exclusive _OR_  y operador de asignacion               | C ^= 2 es equivalente a C = C ^ 2   |
	  |----------+--------------------------------------------------------------+-------------------------------------|
	  | | *=*      | Bitwise inclusive _OR_  y operador de asignacion               | C | *=* 2 es equivalente a C = C | 2  |
	  |----------+--------------------------------------------------------------+-------------------------------------|

	  *OPERADORES RELACIONALES* 
	  |----------+--------------------------------------------------------------+---------------------------|
	  | Operador | Descripcion                                                  | Ejemplo                   |
	  |----------+--------------------------------------------------------------+---------------------------|
	  | *==*       | Chequea si dos operandos son iguales o no y si lo son        | (A == B) No es verdadero  |
	  |          | entonces la condicion se vuelve verdadera                    |                           |
	  |----------+--------------------------------------------------------------+---------------------------|
	  | !=       | Chequea si dos operandos son iguales o no y si lo son        | (A != B) es verdadero     |
	  |          | entonces la condicion se vuelve verdadera.                   |                           |
	  |----------+--------------------------------------------------------------+---------------------------|
	  | >        | Chequea si el valor del operando de la izquierda             | (A > B) no es verdadero   |
	  |          | es mayor que el valor del operando de la derecha, si lo es   |                           |
	  |          | la condicion es verdadera.                                   |                           |
	  |----------+--------------------------------------------------------------+---------------------------|
	  | <        | Chequea si el valor del operando de la derecha               | (A < B) es verdadero      |
	  |          | es mayor que el valor del operando de la izquierda, si lo es |                           |
	  |          | la condicion es verdadera.                                   |                           |
	  |----------+--------------------------------------------------------------+---------------------------|
	  | >=       | Chequea que el valor del operando de la izquierda es mayor o | (A >= b) no es versdadero |
	  |          | igual que el valor del operando de la derecha.               |                           |
	  |----------+--------------------------------------------------------------+---------------------------|
	  | <=       | Chequea que el valor del operando de la izquierda es menor o | (A <= B) es verdadero     |
	  |          | igual que el valor del operando de la derecha.               |                           |
	  |----------+--------------------------------------------------------------+---------------------------|

*** DONE Operadores de cambio de bits(Bitwise Operators)
	CLOSED: [2023-09-20 mié. 14:50]
	- *C* Posee los operadores *Bitwise*. Estos operadores trabajan
 	  a nivel de bits en valores enteros.
	- Uno de los mayores uso de los operadores Bitwise _AND_ y _OR_
	  es crear y probar bits individuales en una variable. se puede
	  usar los bits individuales para almacenar opciones que devuelvenç
	  una o dos condiciones.
	- Se puede usar una sola variable tipo entero para almacenar
	  las caracteristicas de una persona.
	  - Almacenar en un bit si es hombre o mujer.   
	  - Otros 3 bit si habla Español, Frances o Ingles
	  - Otro para saber si gana mas de 50000 
	  - In solo 4 bits tienes cantidad sustancial de infomación 

	*NÚMEROS BINARIOS*
	- Son aquellos números que guaradn zeros y unos
	- Estos pueden tener cualquier longitud. ej:
      01
	  10001001 
	- Todo numero binario tiene un correspondiente numero en decimal ej:
	|----------------+----------------|
	| Numero binario | Numero decimal |
	|              1 |              1 |
	|             10 |              2 |
	|             11 |              3 |
	|            ... |            ... |
	|        1010111 |             87 |
	|----------------+----------------|
	- Cada posición por numero binario tiene un valor.
	  Por cada digito multiplico los digitos por su valor de posición
	  al final adiciono todos los valores para obtener todos los valores finales de los productos
	  en general la *posición de los valores* en número binario es la potencia de 2.
	 Ejemplo con el valor binario 01101001 es 105 en decimal. 
		 
	|-------+------+------+------+-----+-----+-----+-----+-----------|
	|   128 |   64 |   32 |   16 |   8 |   4 |   2 |   1 | resultado |
	|-------+------+------+------+-----+-----+-----+-----+-----------|
	|     0 |    1 |    1 |    0 |   1 |   0 |   0 |   1 |       105 |
	|-------+------+------+------+-----+-----+-----+-----+-----------|
	|       |      |      |      |     |     |     | 1x1 |         1 |
	|       |      |      |      |     |     | 0x2 |     |         0 |
	|       |      |      |      |     | 0x4 |     |     |         0 |
	|       |      |      |      | 1x8 |     |     |     |         8 |
	|       |      |      | 0x16 |     |     |     |     |         0 |
	|       |      | 1x32 |      |     |     |     |     |        32 |
	|       | 1x64 |      |      |     |     |     |     |        64 |
	| 0x128 |      |      |      |     |     |     |     |         0 |
	|-------+------+------+------+-----+-----+-----+-----+-----------|
	
	
	*OPERADORES BITWISE* A = 60 B = 13
 	|----------+-----------------------------------------------------------------+------------------------------|
	| Operador | Descripcion                                                     | Ejemplo                      |
	|----------+-----------------------------------------------------------------+------------------------------|
	| &        | Operador Binario _AND_  copia el bit en el resultado              | (A & B) = 12,i.e 0000 1100   |
	|          | si existe en ambos bandos números                               |                              |
	|----------+-----------------------------------------------------------------+------------------------------|
	| |        | Operador Binario _AND_  copia el bit en el resultado              | (A | B) = 61,i.e 0011 1101   |
	|          | si existe aunque sea en un bando de uno de los                  |                              |
	|          | números.                                                        |                              |
	|----------+-----------------------------------------------------------------+------------------------------|
	| *^*        | Operador Binario _XOR_ copia el bit en el resultado               | (A xor B) = 49,i.e 00110001  |
	|          | si existe aunque sea en un bando de uno de los                  |                              |
	|          | números pero no en ambos.                                       |                              |
	|----------+-----------------------------------------------------------------+------------------------------|
	| ~        | Operador Binario complemento a UNO, es un operador unario       | (~A)= -61,i.e 1100 0011      |
	|          | cambia los bits de 1 a 0 y de 0 a 1                             | en complemento a 2´s         |
	|----------+-----------------------------------------------------------------+------------------------------|
	| <<       | Operador Binario Left Shift, mueve a la izquierda los           | A << 2 = 240, i.e, 1111 0000 |
	|          | bits del operando de la izquierda tantas veces diga el operando |                              |
	|          | de la derecha.                                                  |                              |
	|----------+-----------------------------------------------------------------+------------------------------|
	| >>       | Operador Binario Right Shift, mueve a la derecha los            |                              |
	|          | bits del operando de la izquierda tantas veces diga el operando | A >> 2 = 15, i.e, 0000 1111  |
	|          | de la derecha.                                                  |                              |
	|----------+-----------------------------------------------------------------+------------------------------|
	
	*TABLA DE LA VERDAD*	
	|---+---+-------+-------+-------|
	| p | q | p & q | p | q | p ^ q |
	|---+---+-------+-------+-------|
	| 0 | 0 |     0 |     0 |     0 |
	| 0 | 1 |     0 |     1 |     1 |
	| 1 | 1 |     1 |     1 |     0 |
	| 1 | 0 |     0 |     1 |     1 |
	|---+---+-------+-------+-------|
 #+BEGIN_SRC C
   int main(){

	  int result = 0;
	  unsigned int a = 60; // 0011 1100
	  unsigned int b = 13; // 0000 1101

	  result = a & b;      // 0000 1100
	  result = a | b;      // 0011 1101
	  result = ~a;         // 1100 0011
	  result <<= 2;		   // 1111 0000	
	  result >>= 4;        // 0000 1111

	  printf("El resultado de result es: %d",result);

	  return 0;	 

	}
 #+END_SRC
*** DONE Los operadores de casteo(cast) y de cambio de tamaño(sizeof) (The Cast and sizeof Operators)
	CLOSED: [2023-09-20 mié. 17:53]

  _CONVERSION IMPLICITA_
  - En c y c++ hay conversion implicita de datos y estas se realizan entre integers y floats (POR AHORA)
  - Se siguen las siguientes reglas:
	- Cuando se asigna un flotante a un entero la parte despues de la coma se elimina truncadose el valor ej  75.45 seria 75. 
	- Si se realiza una operacion aritmetica entre dos enteros la porcion despues de la coma se descarta incluso si es un flotante.
	- Si un elmento es un *int* y el otro es un *float* la operacion es de punto flotante.
    #+BEGIN_SRC C

		int   x = 0;
		float y = 12.125
		x = y     // Aqui el valor al asignarse quedaria 12;

		int x2 = 12;
		int x3 = 5;
		float y = x2 / x3 // EL resultado aqui­ va a ser 2.0 aunque el 
						//Verdadero resultado es 2.4 
    #+END_SRC

  _CONVERSION EXPLICITA_
  - La conversion explicita se hace poniendo tipo de dato al que se quiere convertir poninendo el tipo de dato delante y entre parentesis.
	- Cuando se convierte de un tipo a otro se toma en cuenta la presedencia de operadores. Esto significa que se convertira primero y luego se realizara la operaciÃ³n aritmetica.
	
    #+BEGIN_SRC C

	  (int)21.51 + (int)26.99  //Se convierte a entero y luego se suma
	  // 21     +      26        
	  (float)21 + (float)26
	  // 21.0	+      26.0	
     #+END_SRC

    - El operador sizeof (es un operador aunque que paresca una funcion) se usa para saber el tamaño 
	  de las variables en bytes almacenados en memoria. 
	  - Se usa en tiempo de compilación a menos que se estime en tiempo real el tamaño de la variable de tipo arreglo.
	  - El argumento de sizeof puede ser:
		1. Una variable
		2. El nombre de un arreglo
		3. El nombre de un tipo basico de datos (*int* *float*) ect...
		4. El nombre de un tipo de dato derivado
		5. Una expresion
  
    #+BEGIN_SRC C

     int c = 10;
     sizeof(c);
     sizeof(int);
     sizeof( 1 + 1);

    #+END_SRC
*** DONE Precendencia de Operadores (Operator Precendence)
	CLOSED: [2023-09-20 mié. 19:56]
	La precendencia de operadores determina los grupos de terminos y como se evalua 
	una expresion.
	- *C* Establece el orden de mediante una precedencia definida.
	- Se debe usar parentese para aclarar bien la precedencia.
    - Si dos operadores tienen la misma precendencia al regla de *asociación* se aplica   
	- Si comparten el mismo operando se ejecuta deacorde al orden en el cual ellos ocurren en la declaracion
	  - para la mayoria de los operadores el orden es de izquierda a derecha.
		 _1==2!=3_  se evalua de izquierda a derecha. lo que equivale ((1==2)!=3) 

	Tabla de precedencia de la mayor a la menor (TUTORIALS POINTS)
	|-----------------+---------------------------------+---------------------|
	| Categoria       | Operador                        | Asociatividad       |
	|-----------------+---------------------------------+---------------------|
	| Posfija         | () [] -> . ++ --                | Izquierda a derecha |
	|-----------------+---------------------------------+---------------------|
	| Unitario(Unary) | + - ! ~ ++ -- (type) * & sizeof | Derecha a Izquierda |
	|-----------------+---------------------------------+---------------------|
	| Multiplicativa  | * / %                           | Izquierda a derecha |
	|-----------------+---------------------------------+---------------------|
	| Aditiva         | + -                             | Izquierda a derecha |
	|-----------------+---------------------------------+---------------------|
	| Cambio(Shift)   | <<>>                            | Izquierda a derecha |
	|-----------------+---------------------------------+---------------------|
	| Relacional      | <<= >>=                         | Izquierda a derecha |
	|-----------------+---------------------------------+---------------------|
	| Igualdad        | *==* *!=*                           | Izquierda a derecha |
	|-----------------+---------------------------------+---------------------|
		
    
	|-------------+--------------------------------+---------------------|
	| Categoria   | Operador                       | Asociatividad       |
	|-------------+--------------------------------+---------------------|
	| Bitwise AND | &                              | Izquierda a derecha |
	|-------------+--------------------------------+---------------------|
	| Bitwise XOR | ^                              | Izquierda a derecha |
	|-------------+--------------------------------+---------------------|
	| Bitwise OR  | |                              | Izquierda a derecha |
	|-------------+--------------------------------+---------------------|
	| AND Logico  | &&                             | Izquierda a derecha |
	|-------------+--------------------------------+---------------------|
	| OR Logico   | ||                             | Izquierda a derecha |
	|-------------+--------------------------------+---------------------|
	| Condicional | ?:                             | Derecha a Izquierda |
	|-------------+--------------------------------+---------------------|
	| Asignación  | *=* += -= *= /= %= <<= >>= &= ^= | Derecha a Izquierda |
	|-------------+--------------------------------+---------------------|

#+BEGIN_SRC C
	//Ejemplo de precedencia en un arreglo
	#include <stdio.h>

	int main()
	{

		int array[10]= {1,2};
		int count = 0;

		array[++count] = 30; //Primero incrementa y luego asigna
		array[count++] = 30; //Primero asigna y luego incrementa

		for (int i = 0;i < 2; i++) 
			printf("El no %d es %d ",i+1,array[i]);


		return 0;
	}


#+END_SRC

*** DONE Desafio Convierte los minutos en años y días (Challenge Convert minutes to years and days
	CLOSED: [2023-09-20 mié. 20:50]
	- Escriba un programa que convierta de minutos a dias y años
	  el programa le preguntara al usuario los minutos atravez de la 
	  terminal.
    - El programa debera mostrar la salida en minutos entonces su equivalente en 
	  años y días.
      - los minutos de entrada serán un *int*
	  - El resto de las variables serán *double*	
	    - Minutos de un año.
		- Años.
        - Dias.
#+BEGIN_SRC C
  //Solución

	#include <stdio.h>

	int main(int argc, char *argv[]){
		int minutes = 0;
		double min_a_year = 0,years = 0.0, days = 0.0;
		printf("Diga la cantidad de minutos deseada: \n");
		scanf("%d",&minutes);

		min_a_year = (60 * 24 * 365);
		years      =  minutes / min_a_year;
		days       = (minutes / (60.0 * 24.0));

		printf("Los minutos son: %i minutos \n",minutes);
		printf("Los minutos de un anio en dias son: %f minutos \n",days);
		printf("Los minutos de un anio son: %f minutos \n",years);

		return 0;
	}

#+END_SRC

*** DONE Desafio Muestra el tamanio de los tipos de datos basicos (Challenge Print the byte size of the basic data type)
	CLOSED: [2023-09-20 mié. 21:22]
	- Imprima el tamaño de cada uno de los tipo de datos básicos
    - Se deben mostrar los siguentes tipo
	  1. int 
      2. char 
      3. long 
      4. long long 
      5. double 
      6. long double
	- Se puede usar el especificador de formato %zd para formatear cada tamanio.
    - Usar el operador *sizeof*
	- (Opcional pero muy recomendado) Probar el programa en otras computadoras para 
	  ver otros resultados.
 #+BEGIN_SRC C

   #include <stdio.h>

   int main(void){
	   printf("El valor del tipo char es: %zd \n", sizeof(char));
	   printf("El valor del tipo int es: %zd \n", sizeof(int));
	   printf("El valor del tipo long es: %zd \n", sizeof(long));
	   printf("El valor del tipo long long es: %zd\n", sizeof(long long));
	   printf("El valor del tipo float es: %zd \n", sizeof(float));
	   printf("El valor del tipo double es: %zd \n", sizeof(double));
	   printf("El valor del tipo long double es: %zd \n", sizeof(long double));

	   printf("\n\n") ;

	   printf("El valor del tipo char es: %u \n", sizeof(char));
	   printf("El valor del tipo short es: %u \n", sizeof(short));
	   printf("El valor del tipo int es: %u \n", sizeof(int));
	   printf("El valor del tipo long es: %u \n", sizeof(long));
	   printf("El valor del tipo long long es: %u\n", sizeof(long long));
	   printf("El valor del tipo float es: %u \n", sizeof(float));
	   printf("El valor del tipo double es: %u \n", sizeof(double));
	   printf("El valor del tipo long double es: %u \n", sizeof(long double));

	   return 0;
   }


 #+END_SRC

** DONE Estructuras de control(Control Flow) [8/8]
   CLOSED: [2023-09-24 dom. 19:17]
*** DONE Resumen (Overview)
	- Las declaraciones dentro de un archivo fuente generalmente se ejecuta desde arriba hacia abajo
	  en el orden que aparece.
	- Las declaraciones de controles de flujo de rompen con el flujo de ejecucion empleando la 
      la toma de deciciones, la ramificacion y permiten que condicionalmente se ejecute se
	  bloques de codigo deseados. Estas estructuras de controlde flujo son:
	   - Declaracion de toma de desiciones(if-then,if-then-else,switch,goto)
		 - Si una condicion es verdadera entonces las declaracion o declaraciones se 
		   ejecutan.
		 - Si una condicion es falsa se ejecutaran otras declaraciones.

		 Declaraciones *IF*
		|------------------+----------------------------------------------------------------|
		| Declaraciones    | Descipción                                                     |
		|------------------+----------------------------------------------------------------|
		| if               | Las declaraciones if consiste en expresiones boolenas,         |
		|                  | seguida por una o mas declaraciones                            |
		|------------------+----------------------------------------------------------------|
		| if-else          | Una expresion if está seguida de una expresion else            |
		|                  | y esta se ejecuta si la expresion boolena del if es falsa.     |
		|------------------+----------------------------------------------------------------|
		| if-else anidados | Se puede usar un grupo de declaraciónes if-else dentro de otra |
		|                  | declaracion if-else                                            |
		|------------------+----------------------------------------------------------------|

	   - Declaraciones de ciclos(for,while,do-while)
	   - Declaracion de ramificación (break, continue,return) 
		 Las declaraciones de ciclos for while ect... Permiten crear
		 declaraciones de codigo no repetido. que se ejecutaran dentro de dicho
	     ciclo. Los ciclos tienen iteracion finita,o ilimitada si se usa una
		 variable booleana dentro de la expresion del ciclo.

		 *CICLO*
		|-----------------+-------------------------------------------------------------------|
		| Declaraciones   | Descipción                                                        |
		|-----------------+-------------------------------------------------------------------|
		| ciclo *WHILE*     | Se repite las declaraciones o grupo de declaraciones mientras     |
		|                 | una condicion es verdadera. Prueba la condicion antes de ejecutar |
		|                 | el cuerpo del ciclo                                               |
		|-----------------+-------------------------------------------------------------------|
		| Ciclo *FOR*       | Ejecuta una secuencia de declaraciones multiples veces y          |
		|                 | abrevia el codigo que maneja la variable del ciclo.               |
		|                 |                                                                   |
		|-----------------+-------------------------------------------------------------------|
		| ciclo do-while  | Similar al while excepto que primero ejecuta del cuerpo           |
		|                 | de la funcion y  al final  chequea la condición                   |
		|-----------------+-------------------------------------------------------------------|
		| ciclos anidados | Los ciclos anidados son ciclos dentro de ciclos                   |
		|-----------------+-------------------------------------------------------------------|

*** DONE Declaraciones IF(if statements) 
	CLOSED: [2023-09-24 dom. 19:16]
	- En *C* las declaraciones if son una de las formas de toma de deciciones que 
      tiene el lenguaje.

	  *if ( expresion ){*
		*declaracion del programa1*
		*declaracion del programa2*
	  *}*

	- En la declaracion anterior chequea si la expresion es verdadera para ejecutar 
	  las declaraciones del programa. 
    - *OJO* se puede ejecutar eliminar las llaves en un if-else o cliclos si las 
	  declaraciones subsecuentes solo ocupan una linea. ej:

 #+BEGIN_SRC C

     int data = 0;
	 for (int i = 0;i <= 10 ;i++)
		 if ( i%3 ) 
			 continue;
		 else            // No usar parentesis aquí puede causar incertidumbre
			 data += i;  // en el formateador.
	 printf("%i",data);
   return 0;

 #+END_SRC

	- Al no haber mas de una declaracion y validacion por linea se eliminan las
	  llaves.

 #+BEGIN_SRC C

   int score = 95;
   int big   = 90;

   // Declaracion de if, sin llaves
	if(score > big)
	   printf("Jackpot!\n");
   // Declaracion compuesta de if, con llaves
	if(score > big){
	   score++;
	   printf("Win!\n");
	}

 #+END_SRC

 #+BEGIN_SRC C
	//Chequea que el número es primo o no
   #include <stdio.h>

   int main(){
	   int number_to_test = 0, remainder = 0;
	   printf("Inserte un valor a ser probado:");
	   scanf("%i",&number_to_test);
	   remainder = number_to_test % 2;

	   if ( remainder == 0 ) 
		  printf("The number is even. \n");
	   else            
		  printf("The number is odd. \n");

	   return 0;
   }
 #+END_SRC
 	- Se pueden manejar deciciones complejas adicionando declaraciones
	  a la clausula else
 #+BEGIN_SRC C
	// Para implementar la funcion de signo 
   #include <stdio.h>

   int main(){
	   int number = 0, sign = 0;

	   printf("Por favor escriba el número:");
	   scanf("%i",&number);

	   if ( number < 0 ) 
		  sign = -1;
	   else if (number == 0 )      
			sign = 0;
	   else   //Debe se positivo
		  sign = 1;      

		printf("Sign = %i\n",sign);

	   return 0;
   }

 #+END_SRC    

	- Las declaraciones if anidadas se ejecutan a medida que las condiciones se ejecuta 
	  externas se ejecutan ej:   

 #+BEGIN_SRC C

   if ( gamesIsOver == 0 ) 
	  if (playerToMove == you )      
		printf("Your move \n");
	  else   
		printf("My move\n");
   else
		printf("The game is over\n");

	// Otra forma mas conocida con las llaves

   if ( gamesIsOver == 0 ) {
	  if (playerToMove == you ){      
		printf("Your move \n");
	  }else{   
		printf("My move\n");
	  }
	}
   else{
		printf("The game is over\n");
   }

 #+END_SRC    

    - El operador ternario toma una condicion y dos expresiones.
	  *condicion ? expresion1 : expresion2* 
	
 #+BEGIN_SRC C

   if ( gamesIsOver == 0 ) 
	  if (playerToMove == you )      
		printf("Your move \n");
	  else   
		printf("My move\n");
   else
		printf("The game is over\n");

	// Otra forma mas conocida con las llaves

   if ( gamesIsOver == 0 ) {
	  if (playerToMove == you ){      
		printf("Your move \n");
	  }else{   
		printf("My move\n");
	  }
	}
   else{
		printf("The game is over\n");
   }

 #+END_SRC    
	- Las operaciones ternarias son declaraciones if else las cuales evaluan las
	  expresiones en dependencia de la condiciones dadas
	- Puede existir ternarias anidadas
	  *condicion ? expresion : expresion2*
	  *condicion ? condicion ? expresion 2 : expresion3 : expresion1*
 #+BEGIN_SRC C

   int data = 0;
   int data2 = 0;
   data 2 = data > 0 ? 1 : -1;
   printf("%i",data2);
   printf("%i",(data > 0 ? data < 10 ? data : 10 : data ));

 #+END_SRC	  
	  	  
*** DONE Declaraiones switch (switch statements)
	CLOSED: [2023-09-24 dom. 19:16]
	Las declaraciones switch hacen posibles la multiple selección
	de varias alternativas. Hacer uso de switch permiten obtimizar el codigo escrito.
    Este se usa cuando se existen multiples alternativas y escribir declaraciones
	if-else no es recomendado ya que el codigo se extenderia y se ofuscaria. 

	- La condicional switch recibe un parametro y esta se compara por los *case* que examinan si tienen la misma condicion que se le esta pasando al swicth
	- El switch debe cumplir varias condiciones para funcionar correctamente:
	  1. Despues del *case* no hace falta poner parentesis.
	  2. Dentro del *case* se ejecuta todas las condiciones condiciones que se pongan.
	  3. Los *case* son constantes o expresiones constantes. 
	  4. El switch se le pone una condicion *default* (No obligatoria) por defecto
		 para que se ejecute en caso de que de las demas opciones no coincidan.
	  5. Si no se pone *break* al final de un *case* se evaluara los siguientes *case*.
 #+BEGIN_SRC C
		size_t i = 1;
			_Bool is_true(){
				return 1;
			}

		switch (i) {
			case 0: 
				printf("El valor es cero \n"); //Los case pueden 
				i = is_true();                 //ejecutar varias 
				break;                         //varias condiciones
			case 1:
				printf("El valor es uno \n");  //Como i == 1
			case 2:                            //Se evalua case 1: 
											   //al no haber break 
				printf("El valor es dos \n");  //se evalua case 2
				break;                         //sin preguntar
			case 3:
				printf("El valor es tres \n"); // Multiples declaraciones de 
				printf("El valor es 4 \n");    // de funciones, se ejecutan ambas.
				break;
			default:
				printf("No coincide con ningun valor predeterminado.");
				//Este se ejecutara si no coincide con ninguna de las 
				//opciones anteriores
		}
 #+END_SRC

	- Los GOTO saltan de un punto del codigo al otro con la etiqueta señalada
	- No se aconseja usar GOTO a menos que sea nesesario los GOTO ya que 
	  tiende a crear codigo espagueti.

 #+BEGIN_SRC C
   //Este un caso muy especifico de goto donde se puede usar sin problema
   //Aqui en vez de varias break por funcion se usa un solo goto para
   //terminar el ciclo de las funciones
   for(int i = 0;i < 10;i++){
	   for(int j = 0;j< 10;j++){
		   for(int k = 0;k < 10;k++){
				   //si quiero salir del ciclo total tengo que hacer un break
				   //en cada uno de los loops 
			   if(i == 5)
				   break;
			   else
				   funcion_a_ejecutar();
		   }
		   if(i == 5)
				   break;
			   else
				   funcion_a_ejecutar();
	   }
	   if(i == 5)
			   break;
		   else
			   funcion_a_ejecutar();
   }


   for(int i = 0;i < 10;i++){
	   for(int j = 0;j< 10;j++){
		   for(int k = 0;k < 10;k++){
			   if(i == 5)
		   goto label1;
		   }
	   }
   }

   label1:  
	   printf("Termino el ciclo me voy a saltar el proximo printf.");
   goto label2;
	   printf("No me veras nunca el goto me va a saltar siempre.");

   label2:
   return 0;

 #+END_SRC

*** DONE Desafio determine la cantidad de pago semanal (Challenge Determine amount of weekly pay)
	CLOSED: [2023-09-24 dom. 19:16]
	- Crear un programa que calcule el pago semanal.
	  - EL programa debera preguntar al usuario el numero de horas
		trabajada via el teclado
 	  - Se debe asumir que:
		- la politica de pago es de 12$/hora.
		- El tiempo extra se paga como 1.5 * la politica de pago
		- las tazas de intereses se cobra:
			- 15% a los primeros $300  
			- 20% a los proximos $150
			- 25% despues de los 450 

 #+BEGIN_SRC C
	#include <stdio.h>

	//- Crear un programa que calcule el pago semanal.
	//- EL programa debera preguntar al usuario el numero de horas
	//  trabajada via el teclado
	//- Se debe asumir que:
	//- la politica de pago es de 12$/hora.
	//- El tiempo extra se paga como 1.5 * la politica de pago
	//- las tazas de intereses se cobra:
	//- 15% a los primeros $300  
	//- 20% a los proximos $150
	//- 25% despues de los 450 

	//- Se tiene que usar las if else

	#define PAYRATE     12.00  
	#define TAXRATE_300   0.15
	#define TAXRATE_150	  0.20
	#define TAXRATE_REST  0.25
	#define OVERTIME      40

	int main(int argc, char *argv[]) {
		double WORK_TIME = 0.0;
		double result = 0.0;
		double tax = 0.0;

		printf("Escriba las horas trabajadas: ");
		scanf("%lf",&WORK_TIME);

		if(WORK_TIME > OVERTIME) 
			result = (((WORK_TIME - OVERTIME) * (1.5 * PAYRATE)) + (OVERTIME * PAYRATE));
		else
			result =  WORK_TIME * PAYRATE;  

			printf("El tiempo trabajado es de: %lf \n",WORK_TIME);
			printf("El salario antes de impuesto es de: %lf \n",result);

			if(result > 450)
				tax = ((result - 450) * TAXRATE_REST) + (150 * TAXRATE_150) + (300 * TAXRATE_300);
			else if(result > 300 && result <= 450)
				tax = ((result - 300) * TAXRATE_150) + (300 * TAXRATE_300);
			else
				tax = result * TAXRATE_300;

			printf("Impuestos: %lf \n",tax);
			printf("Salario despues de impuestos: %lf \n",result - tax);


		return 0;
	}
 #+END_SRC
 
*** DONE For loop 
	CLOSED: [2023-09-24 dom. 19:16]
   - Los ciclos for trabajan cuatro estados
	 1. inicializacion 
	 2. chequeo de iteracion
	 3. ejecucion de iteracion 
	 4. modificacion de ciclo (incremento o decremento, si existe el ciclo)
   - Las estructuras de control que tiene el ciclo son las ya conocidas: 
	 1. *break*
	 2. *continue*
   - Las estructuras sirven para romper los ciclos o pasar a la próxima 
	 iteracion del mismo.
   - Los ciclos for pueden iterar sobre varios elementos a la vez.

 #+BEGIN_SRC C

   //Aquí se itera sobre los elementos i e j
   for(int i = 0,j = 2;i <= 5; i++,j = j + 2){
	   printf("%5d",i*j);
	}

 #+END_SRC

	- Se pueden ejecutar operaciones dentro de los ciclos for.

 #+BEGIN_SRC C

   unsigned long long sum = 0LL;
   unsigned int count     = 5;

   for(unsigned int i = 0;i < count;sum += i++) 
   {
   // En este caso se sumara antes de incrementar i 
   // y despues se incrementara i
	   printf("%5d",sum);
   }	

 #+END_SRC 

   - Se pueden crear ciclos infinitos con *for* y *while*.

 #+BEGIN_SRC C

   for(;;) {
	   //Se ignora los parametros de la expresion del 
	   //ciclo y se itera infinitamente. 
   }
	   // El ciclo while se vera en la proxima iteración
   while(true){}

 #+END_SRC

*** DONE While and Do-While
	CLOSED: [2023-09-24 dom. 19:16]
 - Los ciclos *while* y do while son mecanismos para repetir declaraciones
   que permiten la ejecucion de dicha declaración tanto como la expresion
   sea cierta.
 - Los ciclos *while* evaluan las expresiones y despues las declaraciones dentro de
   las llaves.
 - Los ciclos *do-while* evaluan las declaraciones y despues las expreciones 
   dentro de las llaves.
 - La sintasis general es:

 #+BEGIN_SRC C

   while(expresion){
	   declaracion_1;
	   declaracion_2;
   }

   do {
	   declaracion_1;
	   declaracion_2;
   } while(expresion)

 #+END_SRC
   
 #+BEGIN_SRC C

   #include <stdio.h>	

   int main(void){
	   int count = 0;
	   while(count <= 5){
			printf("%i\n",count);
	   }
		return 0;
   }

 #+END_SRC

- Ciclo  controlado por logica
 #+BEGIN_SRC C
   #include <stdio.h>	

   int main(void){
	   int num = 0;
	   while(num != -1)
			/* Loop actions */
			scanf("%d\n",&num);

		return 0;
   }
 #+END_SRC
 
 #+BEGIN_SRC C
	//Ejemplo 1
   do 
	   scanf("%d",&number);  
   while(number != 20);

	//Ejemplo 2
	int number = 4;
	do {
		printf("\nNumber = %d",number);
		number++
	}while(number < 4)
	
	//Ciclo while controlado por lógica
	while(scanf("%i",&num) == 1)

 #+END_SRC

*** DONE Nested loops and loop control-break 
	CLOSED: [2023-09-24 dom. 19:16]
 #+BEGIN_SRC C

   for(int i = 0;i <= count;i++) 
	 sum = 0; //inicializa la suma en un ciclo interior
		for(int j = 0;j <= i;j++) 
			sum += j;
		printf("\n%d\t%d",i,sum);

 #+END_SRC
 
 #+BEGIN_SRC C

   for(int i = 0;i <= count,++i){
	   sum = 1;
	   j = 1;
	   while(j < i){
		   sum += ++j;
		   printf(" + %d",j);
	   }
	   printf(" =%d",sum);
   }

 #+END_SRC
 - Existe la situacion donde no se desea terminar o ejecutar la declaracion en 
   en esa etapa del ciclo. La declaracion *continue* permite saltar hacia la
   proxima etapa.
 - La ventajas de usar continue es que evitas usar bloques anidados y mejora la 
   lectura del código.
 - Las declaraciones *break* permiten romper el ciclo que se encuentra en ejecucion.
 - Si hay varios ciclos anidados el *break* si no esta en el ciclo principal rompera
   su ciclo y despues el principal continuara. Si es del ciclo principal entonces
   rompera todos los ciclos dentro. 
 #+BEGIN_SRC C
   #include <stdio.h>
   enum Day {Monday,Tuesday, Wednesday,Thursday,Friday, Saturday, Sunday }

   int main(void){
	for(enum Day day = Monday; day <= Sunday;++Day){
		if(day == Wednesday)
			continue;

		  printf("It's not Wednesday");
		}
   }
 #+END_SRC
 
 #+BEGIN_SRC C
	while( p > 0) {
		printf("%d\n",p);
		scanf("%d",&q);
		while(q > 0){
			printf("%d\n",p * q);
			if(q > 100)
				break;
			scanf("%d",&q);
		}
		if(q > 100)
			break;
		scanf("%d",&p);
	}
 #+END_SRC
 
*** DONE Desafio Adivina el número (Challenge Guess the number)
	CLOSED: [2023-09-24 dom. 19:17]
	- Adivina el numero es un juego de adivinanzas donde el usuario tiene
	  que adivinar un numero que se genera aleatoriamente por el sistema
      y el usuarario tiene que constestar un numero de veces X hasta constestar el
	  correcto.
    - EL programa debe generar un numero de 0 al 20
    - Si el número insertado por el usuario es mayor que 20 o menor que 0 entonces
	  se le debe decir al usuario que el numero que inserto no esta dentro de los valores
	  deseados.
    - El programa debe indicar que el numero es menor o mayor que el número a adivinar.
	- EL jugador pierde si no contesta el valor generado por el sistema.

 #+BEGIN_SRC C

   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>      //Para obtener el id de los procesos
   // #include <time.h>     

   #define MAXIMO 20

   int main()
   {
	   int times = 5;
	   int numero = 0,valor = 0;

	   // printf("Id del proceso %d",getpid());
	   //time_t t;  //Si tuviese de que usar time como pide el ejercicio
	   printf("Hola juguemos un juego tienes 5 oportunidades para adivinar un numero del 0 al %d \n Deseas jugar \n [1] - Si o [2] - No \n",MAXIMO);
	   scanf("%d",&numero);

	   if(numero == 1){
		   srand(getpid());
		   // numero = (rand() % 20) + 1; // suma + 1 u otra cantidad aumenta 
									   // el número mínino. 
		   //srand((unsigned) time(&t));  // Para inicializar el random con la seed
									   // time
		   numero = (rand() % 20);

		   while (times != -1) {
			   printf("Seleccione un numero: "); 
			   scanf("%d",&valor);

			   if(valor == numero){
				   printf("Felicidades el numero era %d\n",valor);
				   break;
			   }

			   if(times == 0){
				   printf("Lo siento has perdido el numero era %d\n",numero);
				   break;
			   }

			   if(valor < 0 || valor > MAXIMO){
				   times -= 1;
				   printf("Valor diferente a los valores preestablecidos, te quedan %d intento(s) \n",times + 1);
				   continue;
			   }

			   if(times > 0){
				   times -= 1;
				   printf("%s un poco pero estas cerca te quedan %d intento(s) \n",valor > numero ?"Te pasaste":"Te falta",times + 1);
				   continue;
			   }   
		   }
	   }
	   printf("Gracias por jugar.\n");
	   return 0;
   }

 #+END_SRC

** DONE Arreglos (Arrays) [6/6]
   CLOSED: [2023-09-25 lun. 13:34]
*** DONE Creando y usando arreglo (Creating and using arrays)
	CLOSED: [2023-09-24 dom. 19:31]
   - Los arreglos son elementos utilizados para almacenar datos de forma 
	 secuencial, y usan un tamaño definido por el usuario al ser inicializados.
   - Se usan tipos de datos basicos como enteros o datos 
	 complejos creados por el usuario.
   - Los arreglos en c y c++ no mezclan tipos de datos como las listas en python.
	 usan un solo tipo de datos *siempre*.
   - Al ser declarado con un valor determinado los limita a trabajar con un 
	 tamaño fijo

 #+BEGIN_SRC C

	//Se puede declarar un arreglo con cualquier tipo de dato
	int array1 [10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	int array2 [] = { 1, 2, 3, 4, 5};
	float array3 [] = { 1.3, 2.1, 3.10, 4.3, 5.0};

   //Se puede inicializar los arreglos de sin haberlos inicializado 
   //completamente. El resto de los elementos se inicializa en 0.
  int array5 [10] = { 1, 2, 3, 4, 5};
  
  //Guarda el valor que entra por teclado en la posicion 4
  //de arreglo3
   int i = 4;
  scanf("%f",&array3[i]);
 #+END_SRC

 #+BEGIN_SRC C

  //arreglo de 2 dimensiones
  int numeros[3][4] = {   
		  {10,20,30,40},
		  {15,25,35,45},
		  {47,48,49,50},
 #+END_SRC

 - Ejemplo de usos de arreglos

 #+BEGIN_SRC C
   #include <stdio.h>

   int main(void){
		int grados[10]; 	 // Arreglo sin inicializar para almacenar 10 elm
		int count     = 10;  // Número de valore para leer 
		long sum      = 0;	 // Suma de números	
		float average = 0.0f;// Promedio

		printf("\n Inserte los 10 grados");
		for(size_t i = 0;i < count;i++){
			printf("%2u>",i + 1);
			scanf("%d",&grados[i]);
			sum += grados[i];
		}
		average	= (float)sum/count;
		printf("\n Promedio de los 10 grados es: %.2f",average);
		return 0;
   }	
 #+END_SRC
	
*** DONE Inicializacion (Initialization)
	CLOSED: [2023-09-24 dom. 20:03]
 	- Los arreglos se pueden inicializar completamente, o en caso que el arreglo 
	  sea muy largo con 500 elementos se pueden dejar sin inicializar el resto
	  varios que estos quedaran en cero.
	- C99 adiciona una forma de inicializar los valores especificos del arreglo.
	- No existe forma de inicializar valor forma rapida como en python,
	  los valores se deben inicializar uno a uno.
 #+BEGIN_SRC C

   //Se iniciliza los primeros 3 los demas quedan en cero.
   float sample[500] = { 100.0, 300.0,500.0 };

	//C99 inicialización de valores especificios
   float sample[500] = { [2] = 100.0, [1] = 300.0,[0] = 500.0 };

   //Inicializa la posicion 5 con el valor 12
   int myarray[6]    = {[5] = 212}; 

	//Ejemplo de inicializacion clasica
	#include <stdio.h>
	#define MONTHS 12
	int main(){
		int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31 };
		int index;
		for(int index = 0;index < MONTHS;index++)
			printf("EL mes %d tiene %2d días \n",index + 1,days[index]);


		return 0;
	}

 #+END_SRC
*** DONE Arreglos multidimensionales (Multidimentional Arrays)
	CLOSED: [2023-09-24 dom. 20:23]
	- La inicialización de los elementos de un arreglo multidimentional
	  permiten almacenar elementos en dos o mas dimenciones.
	- Los arreglos de multidimencionales se pueden almacenar de la misma 
	  forma que los arreglos de una dimension.
	- Igual que los arreglos unidimencionales se puede crear arreglos inicializados en 0
	- Los arreglos se pueden visualizar como
		- Arreglos de una dimension como una fila de datos
		- Arreglos de dos dimension como una tabla de datos, matrix o hoja de calculo.
		- Arreglos de tres dimensiones como una pila de tablas de datos.
 #+BEGIN_SRC C

	  // Arreglo de 2 dimensiones
	  int numeros[3][4] = {   
			  {10,20,30,40},    // Valores de la primera fila
			  {15,25,35,45},	// Valores de la segunda fila
			  {47,48,49,50},    // Valores de la tercera fila
		   }

	   // Arreglo de 3 dimensiones
	  int numeros_3[2][3][4] = { //[2] numero de bloques
								 //[3] numero de filas del bloque
								 //[4] numero de columna del bloque
		   {		// Primer bloque de tres filas
			  {10,20,30,40},   
			  {15,25,35,45},	
			  {47,48,49,50},   
		   },
		   {		// Segundo bloque de tres filas
			  {10,20,30,40},   
			  {15,25,35,45},	
			  {47,48,49,50},   
		   },

   };

	  // Arreglo incializado hasta la tercera fila
	  int numeros_2[10][4] = {   
			  {10,20,30,40},   
			  {15,25,35,45},	
			  {47,48,49,50},   
		   }

	   // Arreglos con valores inicializadores con C99
	   // Todas las popsicion no seleccionadas con un valor se inicializan con 0
	  int numeros_2[10][4] = {[0][0] = 1,[1][1] = 5,[2][2] = 9};

 #+END_SRC
	
*** DONE Arreglos de longitud variable (Variable Length Arrays)
	CLOSED: [2023-09-24 dom. 20:38]
  - Los arreglos se definen con valores constantes en la declaración de estos
 - Los arreglos con longitud variable se introducen en C99 y permiten al usuario
  declarar la longitud del arreglos antes de inicializarlos
  #+BEGIN_SRC C
	int longitud = 10;
	int new_array[longitud];  // No se permite hacerlo antes de C99
  #+END_SRC
		
*** DONE Desafio Generar numeros primos (Challenge Generate Prime Numbers)
	CLOSED: [2023-09-25 lun. 10:11]
   - En este desafio se deben imprimir los elementos primos del 3 al 100
   - No se insertaran elementos por el teclado 
   - La salida debe ser todo los numeros primos en una sola linea 
   - Se insertara a mano los dos primeros primos que son 2 y 3.
   - Se usaran ciclos para buscar los números primos y un ciclo para mostralos.
    - Los numeros primos solo son divisible ellos mismos y 1.
	- Ningun numero par es primo.
	- La formula para salir del ciclo interior es:
	  - p / primos[i] >= primos[i];
	  - Hacer una prueba que los numero de *P* no exede la raiz cuadrada de primos[i]

 #+BEGIN_SRC C
	#include <stdio.h>
	#include <stdbool.h>

	int main() {

		int primos[25] = {2,3};
		int pos_actual = 2;
		int init = 0;
		bool es_primo;
		int i = 0;
		for (init = 5; init <= 100 ; init += 2) {
			es_primo = true;
			for (i = 0;i < pos_actual;i++ ) {
				if( init % primos[i] == 0 ){
					es_primo = false;
					break;
				}
			}

			if(es_primo){
				primos[pos_actual] = init;
				pos_actual++;
			}

		}

		for (i = 0; i < pos_actual ; ++i)
			printf("%i ",primos[i] );

		printf("\n");

		return 0;
	}


 #+END_SRC
*** DONE Desafio crear un programa del Clima (Challenge Create Simple Weather program)
	CLOSED: [2023-09-25 lun. 13:34]
	- El programa almacena los Datos del clima en una matriz.
	- Se debe calcular el total de lluvia anual, su promedio anual y el promedio mensual.
	- La matriz sera un arreglo de float de número de 5 filas y 12 columnas.
 #+BEGIN_SRC C
   // EL programa funciona pero no hace todo lo que se le pide

   #include <stdio.h>

   int main() {


	   float data[5][12] = {
		   {2.3,3.3,3.5,4.9,5.3,4.7,2.5,1.02,2.22,3.9,4.1,7.0},
		   {2.3,9.3,7.5,7.9,8.3,4.7,2.5,1.02,2.22,3.9,4.1,7.0},
		   {2.3,3.3,3.5,4.9,9.3,4.87,2.5,1.12,2.42,3.9,4.1,7.0},
		   {8.3,3.3,3.5,4.9,8.3,4.7,2.5,1.02,2.22,3.9,4.1,7.0},
		   {2.3,5.3,3.5,4.9,8.3,4.7,2.5,1.02,2.22,3.9,4.1,7.0},
	   };
	   float promedio_mensual[12]; 
	   float lluvia_anual = 0.0,promedio_anual = 0.0;

	   for(int i = 0;i < 5; i++) {
		   for(int j = 0;j < 12; j++) 
			   lluvia_anual += data[i][j];

		   promedio_anual += lluvia_anual;
		   printf("La lluvia anual del anio 201%d es de %f\n",i,lluvia_anual);
		   lluvia_anual = 0.0;
	   }

	   for (int i = 0;i < 12; i++) {
		   for(int j = 0;j < 5; j++){
			   promedio_mensual[i] += data[j][i];
		   }
		   printf("El promedio mensual es de %lf pulgadas \n",promedio_mensual[i] / 5.0);
	   }


		   printf("El promedio anual es de %f pulgadas",promedio_anual / 5.0);
	   return 0;
   }


 #+END_SRC
** TODO 9. Functions [6/7]
*** DONE Basico (Basic)
	CLOSED: [2023-09-25 lun. 20:30]
	- las funciones son unidades autocontenidas de codigo diseñada para ejecutar
      una o mas tareas.
    - Las funciones en C son iguales a las subrutinas o procedimientos en otros
	  lenguages de programación.
    - Las funciones realizan operaciones para:
	  - Imprimir información en pantalla.
	  - Hacer operaciones con los datos datos en el programa.	
    - Las operaciones en funciones permiten realizar la estrategia de 
	  divide y venceras lo cual permite:
	  1. Disminuir la complejidad de las operaciones. 
	  2. Dividir las funciones en pequeñas subtareas.
	  3. Las subtareas se dividen en pequeñas subtareas eliminando aun 
		 más la complejidad.
	  4. Reduce el codigo duplicado.
	  5. Reduce el tiempo de escritura.
	  6. Reduce el tamaño del codigo fuente.
	  7. Se pueden usar en otros programas.
	- La funcion main en C/C++ es reconocida como la funcion de inicio de un programa. 
*** DONE Definicion de funciones (Defining Functions)
	CLOSED: [2023-09-26 mar. 09:49]
    DECLARACION DE FUNCIONES
	- Las funciones se definen de la siguiente forma
	  *Dato_de_retorno* *Nombre_de_la_funcion* (*parametros* _tipo_de_datos_,otros_datos_separados_por_coma){
		*declaraciones...*
	}
	- La definicion de funciones no deben tener nombres con:
	 - Palabras reservadas.
	 - No tener el mismo nombre que otras funciones incluso dentro de otras 
	   bibliotecas
     - EL nombre de la funcion se declara similar una variable cualquiera 
		- Letras y digitos.
		- EL primer caracter debe ser una letra.
		- EL guion bajo se cuenta como letra. 

	 - Hay tres formas comunes de nombrar una funcion segun la comunidad
	   - Separar cada palarbar del nombre de la funcion por guion bajo, se le conoce 
		 como *snakecase*.
       - Escribir en mayuscula la primera letra de cada palabra 
       - Escribir en mayuscula la primera letra de cada palabra excepto *CamelCase*
		 
	#+BEGIN_SRC C
		void printMessage(void);
	#+END_SRC

	*PROTOTIPOS DE FUNCIONES*
	- Un prototipo de la funcion es una declaracion de definen la una funcion
		- Define su nombre el valor de retorno, y todo los tipos de los parametros.
		- Define todas las especificaciones externas de la funcion. 
	- El prototipo se puede escribir igual que la cabercera de la la funcion en cuestion.
	- El prototipo permite al compilador generar las instrucciones apropiadas a 
	  cada punto se llama la funcion.
	- Se chequea que se esta usando la funcion correctamente en cada invocacion.
	- Cuando se incluye una biblioteca en la cabecera(*header*) del archivo en cuestion.
	  el compilador genera los prototipos correspondientes.

	- Los prototipos de funciones aparecen al principio del archivo, 
	  si no se declaro la funcion en ese espacio.
	- Como buena practica se debe declara los prototipos de las funciones 
	  en cualquier archivo cabecera.
	- El nombre de los parametros declarados en el prototipo no tienen que ser
	  iguales que los que se usan en la definicion de la funcion.
    - Es buena practica siempre incluir todas las declaraciones de las funciones
	  en un solo archivo sin importar donde se llame.
	  - Mantiene las funciones y el programa mas consistente en su disenio.
      - Previene los errores si se decide llamar una funcion desdes otra parte 
		del programa.
 #+BEGIN_SRC C
	 //Declaracion de prototipo 
   #include <stdio.h> 


   void funcion_a_llamar2(int data){
	   printf("Hola mundo %d veces\n",cant);
	}

   void funcion_a_llamar(int);

   int main(){
		 funcion_a_llamar();  // Funcion invocada con el prototipo  
   		 funcion_a_llamar2(); // Funcion invocada sin el prototipo  
	   return 0;
   };


   void funcion_a_llamar(int cant){
	 printf("Hola mundo %d veces\n",cant);
   }

 #+END_SRC 

*** DONE Argumentos y parametros (Arguments and Parameters)
	CLOSED: [2023-09-26 mar. 10:05]
	- Los parametros son los nombres de las variables cuando se declara una funcion.
	- Los argumentos son los datos que se pasan a las funciones cuando estas se invocan,
	  y los tipo deben coincir para que la misma funcione, sino dara un error.

 #+BEGIN_SRC C

   #include<stdio.h>

   //Delcaracion de funcion con parametros	
   void multiplyTwoNumbers(int x, int y){
		int result = x * y;
		printf("The product of %d multiplied by %d is: %d\n",x,y,result);
   }

   int main(){
		
	 // Invocacion de funcion con argumentos
	 multiplyTwonumbers(10,20);
	 multiplyTwonumbers(20,30);
	 multiplyTwonumbers(50,2);

	 return 0;
   }

 #+END_SRC
 
*** DONE Returning data from functions
	CLOSED: [2023-09-26 mar. 14:13]
	- Las funciones la cual su tipo de datos de retorno no sea *void* returnan su 
	 valor con la palabra *return.*
    - Si la funcion retorna un parametro y no se declara su valor de retorno dera error al compilar;
    - Las funciones se invocan y almacenan su resultados en variables con un mismo 
	  tipo de valor de retorno.

 #+BEGIN_SRC C

   int value = invoke_funcion();

 #+END_SRC	 

*** DONE Local and Global variables
	CLOSED: [2023-09-26 mar. 14:37]
	*VARIABLES LOCALES*
	- Las variables que se declaran dentro de una reunion se consideran
	  por inicializacion como locales. Su valor es intriseco a la funcion   
	  donde se declaro. Solo se puede acceder ellas dentro de la funcion donde
      fue declarada.
    - La variable local recibe un valor inicial cada vez que la 
      funcion es invocada. Se considera local si se declara dentro de los
	  ciclos y alternativas *if-else* o *switch*

	*VARIABLES GLOBALES*
	- Contrario a las variables locales existen las variables globales
	  a las cuales se puede acceder desde cualquier parte del programa.
    - Las variables globales tiene el ciclo de vida del programa.
    - Se declaran fuera de cualquier funcion del programa.
	- Si una variable local se declara con el mismo nombre
      de la variable global, no se puede usar la variable global
	  hasta que se salga del bloque de la variable local.  
 #+BEGIN_SRC C
   int myglobal = 0; //Variable global

   int main(){
	 int myLocalMain = 0;//Variable local
	 //Se puede acceder a mi variable global y local
	 return 0;
   }

   void miFuncion(){
		int x; // Variable local 
		// Se puede acceder a x y myglobal, pero no puede acceder
		// myLocalMain
	}

 #+END_SRC

 	- Por buenas practicas es bueno evitar las variables globales por:
	  - Promueve el acoplamiento entre funciones(dependencias)
	  - Es dificil encontrar o localizar un bug en el programa.
      - Una vez se encuentra el bug es dificil de arreglar.
	- Se aconseja usar parametros en funciones 
	- Se hay muchos parametros usar estructuras *struct*	
	  
*** DONE Desafio Escribe algunas funciones (Challenge Write some functions!)
	CLOSED: [2023-09-26 mar. 19:16]
	- Escribe tres funciones en un solo programa que:
	  - Hallar el maximo comun divisor.(resibe 2 int)
	  - Calcula el valor absoluto de un numero (hacer la funcion con float e int)
	  - Calcular la raiz cuadrada de un numero.
		- Si un numero es negativo muestra un mensaje y retorna -1.0
		- Se debe usar la funcion de valorAbsoluto ya emplementada. 
 #+BEGIN_SRC C

	#include <stdio.h>

	int maximo_comun_divisor(int,int);
	float valor_absoluto(float);
	float raiz_cuadrada(float);

	int main() {

		float val = -234.00;
		printf("EL valor absoluto de %f es %f\n",val,valor_absoluto(-234));
		printf("La raiz cuadrada de 25 %f \n",raiz_cuadrada(25) );
			return 0;

		}

	int maximo_comun_divisor(int primero,int segundo){

		int temp;
		while (segundo != 0) {
			temp = primero % segundo;  
			primero = segundo;
			segundo = temp;
		}

		return primero;

	}


	float valor_absoluto(float value1){

		if(value1 < 0)
			return -value1;
		return value1;

	}

	float raiz_cuadrada(float value){
		const float epsilon = .00001;
		float guess  		= 1.0;
		float returnValue   = 0.0;

		if(value < 0){
			printf("Argumentos negativos para la raiz cuadrada.\n");
			returnValue = -1 ;
		}
		else {

			while (valor_absoluto(guess * guess - value) >= epsilon) 
				guess = (value / guess + guess ) / 2.0;

			returnValue = guess;
		}

		return returnValue;

	}

 #+END_SRC

*** TODO Desafio tic tac toe (Challenge Tic Tac Toe) 
** DONE Character Strings [8/8]
   CLOSED: [2023-10-07 sáb 20:57]
*** DONE Resumen (Overview)
	CLOSED: [2023-09-27 mié. 08:39]
	- Las cadenas de caracteres al contrario de las characteres se escriben con comillas dobles.
	- Todo lo que este includo entre doble comillas, incluido los caracteres especiales 
	  y espacios embebidos es una cadena de caracteres.
    - Al final de cada cadena de caracteres se inserta un carater para NULL para representar
      el que la cadena termino este caracter es *\0* .
    - Las cadenas de caracteres siempre terminan con el caracter *\0* por lo que la cadena de 
	  de caracteres es siempre uno mas que la longitud de la cadena de caracteres  
	- El caracter \0 se adiciona al final de la cadena de forma implicita.
    - El compilador lee la cadena hasta donde encuentra el primer caracter \0
	  una vez que encuentre el caracter \0 no mostrara ningun contenido adicional.
 #+BEGIN_SRC C
   char string[10]   = "Alejandro";  // Alejandro tiene 9 caracteres pero se reserva 10 para evitar errores en el programa
								     // al final de la cadena se escribe \0 aunque no se vea.
   char caracter     = "a";          // Aqui hay que poner los caracteres en la casa porque las comillas simple no funcionan en el trabajo.
 #+END_SRC	
 
 #+BEGIN_SRC C
	printf("Hola soy \0 alejandro.");// Aqui llega hasta \0 e imprime solamente "Hola soy"  	
 #+END_SRC

*** DONE Defining Strings
	CLOSED: [2023-09-27 mié. 12:21]
	- En C no hay tipo de datos string 
	  - No hay operadores especiales en el lenguaje para el procesamiento de strings.
 	  - La biblioteca estandar provee un grupo de funciones para manejar los strings.

	- Las cadenas de caracteres se inicializan con longitud fija donde se permite que el compilador las inicialize
	  terminando con un caracter nulo '\\0'
	- Un arreglo de 10 caracteres tiene, 9 caracteres para almacenar y un carater nulo '\\0'
	- Cuando se inicializa el string con mas caracteres de los permitido el compilador 
	  lanzara un advertencia si la cadena es mas larga que el tamaño dado.

 #+BEGIN_SRC C
   // Inicializacion de cadena
   char arr[11] = "Hola mundo";

   // Inicializacion de la cadena con el caracter nulo
   char arr2[] = {'H','o','l','a',' ','m','u','n','d','o','\0'};

   // Inicializacion de la cadena con el caracter nulo
   char arr3[11] = {'H','o','l','a',' ','m','u','n','d','o','\0'};

   // Inicializacion con problema, el compilador permitira 
   // inicializarlo pero dara error en la salida, 
   // ya que muestrara datos no validos al final de la cadena 
   char arr4[10] = {'H','o','l','a',' ','m','u','n','d','o','\0'};

   // Creara la cadena pero dara error imprimir la cadena completa, 
   // el compilador no mostrara errores 
   char arr5[6] = {"Hello!"};

   // Forma correcta de almacenar la cadena. 
   char arr6[7] = {"Hello!"};

	//----------------------------//
   // Declaracion de la cadena
   char arr4[20];
	
   char arra5[100];
   //No se puede inicializar la cadena despues de declararse
   arra5 = "Esto no es valido";

   //Se puede inicializar la cadena con varios elementos como char
   char array1[5];
   array1[0] = {'H'};
   array1[1] = {'o'};
   array1[2] = {'l'};
   array1[3] = {'a'};
   array1[4] = {'\0'}; 
 #+END_SRC
	

  - Para asignar una cadena a un arreglo declarado o inicializado no se puede 
	guardar como otra cadena cualquiera, se debe usar la funcion de la 
	biblioteca estandar *strncpy*.
  - Asignar los caracteres uno a uno es posible.

 #+BEGIN_SRC C

   char na[20];

   na[0] = "h";  //Poner comillas simple en la casa
   na[1] = "e";
   na[2] = "l";
   na[3] = "l";
   na[4] = "o";
   na[5] = "\0";

   // Para mostrar una cadena de caracteres por pantalla se usa printf("%s",na) 
   // sin el & delante de na porque es un arreglo.
	char nombre[] = "Esta es mi cadena de caracteres";
	printf("%s",nombre);

 #+END_SRC
 

 - Para comparar dos cadenas se usa la funcion *strcmp* de la biblioteca estandar
 #+BEGIN_SRC C

   #include <stdlib.h>

   char na[20];

   na[0] = "h";  //Poner comillas simple en la casa
   na[1] = "e";
   na[2] = "l";
   na[3] = "l";
   na[4] = "o";
   na[5] = "\0";

   char nombre[] = "hello"; 
	
   strcmp(na,nombre);

 #+END_SRC

  - Contar carateres en la cadena 
 #+BEGIN_SRC C

	#include <stdio.h>   

	int main(void){

		char str1[] = "Ser o no ser ";
		char str2[] = "esa es la cuestion";
		unsigned int count = 0;

		while(str1[count] != '\0')  // Aqui se usa las comillas simples con "\0"
			++count;

		printf("La longitud de la cadena %s es de %d \n",str1,count);

		count = 0;	

		while(str2[count] != '\0') // Aqui se usa las comillas simples
			++count;

		printf("La longitud de la cadena %s es de %d \n",str2,count);

		return 0;

	}

 #+END_SRC

*** DONE Cadena de caracteres constantes (Constant string)
	CLOSED: [2023-09-28 jue. 10:32]
	*#define* *const* 

	- A veces se desea crear constantes de un programa para mantener el valor inmutable.
	- Estas definiciones permiten mantener los valores del programa hasta su finalizacion. 
	- Las constantes permite crear un solo punto de referencia ya que solo se puede cambiar 
      su valor en la declaracion.

 #+BEGIN_SRC C
	int valor_de_la_casa = 1000;
	const float impuesto  = 0.0015;

	comprada = 0.0015   * valor_de_la_casa;  
	comprada = taxrate  * valor_de_la_casa;  // Esto permite identificar impuesto mejor, porque impuesto
											 // Se visualiza mejor en un program largo que 0.0015
	
 #+END_SRC
	- El preprocesador permite definir constantes con la declaracion *#define*
	- No se usa ; con #define 
	- Cuando se compila el programa el valor 0.0015 *SUBTITUYE* en tiempo de compilación donde quiera 
	  que uso TAXRATE como se ve en el ejemplo a continuacion.
    - *#define* no es una variable, por lo que no se le puede asignar un valor y 
	  sigue las siguientes reglas.
	  - No existe termino local para define, o sea se puede usar en cualquier parte del 
		codigo
      - Se usa como buena practica al principio del programa o dentro de un archivo 
		#include para compartirse dentro de otros archivos del programa.
    - *#define* ayuda hacer el programa mas portable, porque puede ser necesario usar 
	  valores constantes relacionado a una computadora en la cual el programa puede
	  estar corriendo.
	
 #+BEGIN_SRC C

   #define TAXRATE 0.0015
   float miscompras   = 0.0;
   int total_comprada = 10;

   miscompras = 10 * TAXRATE * total_comprada;   // Antes de compilar
   miscompras = 10 * 0.0015 * total_comprada;    // Durante la compilación

 #+END_SRC
	

	- #define se puede usar en cadena de constante de caracteres.

 #+BEGIN_SRC C

   #define BEEP '\a'
   #define TEE 'T'
   #define ESC '\033'
   #define OOPS "Ahora si la cagaste"
	// minuto 5:18
 #+END_SRC
	
	- La palabra reservada *const* se introdujo en el estandar C90 para
	  crear constantes simbolicas. 
	  - Se usa para convertir una declaracion de una variable a una constante.
    - *const* es una aproximacion mas flexible que *#define* porque:
	  - Permite declarar tipos en las variables
	  - Tiene mayor control sobre que parte del programa se puede usar constantes.
    - Otras forma de declarar const es con *enum* pero esto sirve para enteros _solamente_. <- (dudas)
	- Inicializar una arreglo de caracteres y declaralo como const es una buena forma de
	  manejar los mensajes estandares.
	  - Declarar un mensaje como const lo protege de ser modificado
	  - Cualquier intencion de hacerlo resultara en un mensaje de error del compilador.
 #+BEGIN_SRC C
	const int meses = 12; 
	const char message[] = "El mundo termina esta noche.";
 #+END_SRC
	
*** DONE Funciones comunes para manejo de cadenas de caracteres (Common String Function)
	CLOSED: [2023-09-28 jue. 11:00]
	- *C* provee de muchas funciones para el manejo de cadena de caracteres, donde 
	  entra dentro de las mas conocidas:
 #+BEGIN_SRC C
	// Biblioteca donde se encuentra las funciones que se muestran a
    // Continuación 

	#include <string.h>
	#include <stdio.h>
	
	
	int main(){

	const cadena1[] = "Hola me llamo alejandro.";
	const cadena2[] = "Hola me llamo javier.";

   // Obtener el tamanio de una cadena.
   // Esta funcion retorna un int tipo size_t 
	printf("La oracion contiene la longitud de %d \n",strlen(cadena1));     // 25

   // Copia copia en la cadena1 la cadena2
	strcpy(cadena1,cadena2);

   // Copia copia en la cadena1 la cadena2
	strncpy(cadena1,cadena2);



   // Concatena la cadena1 la cadena2
	strcat(cadena1,cadena2);

   // Concatena la cadena1 la cadena2
	strncat(cadena1,cadena2);



   // Compara la cadena1 la cadena2
	strcmp(cadena1,cadena2);

   // Compara la cadena1 la cadena2
	strncmp(cadena1,cadena2);
	return 0;
}
 #+END_SRC
 
 - Ejemplos manipulacion de cadena de caracteres. 

 #+BEGIN_SRC C
	#include <string.h>

	strlen()           //devuelve la longitude de la cadena cadena
						//strlen devuelve un valor en tamaÃ±o que se puede convertir en a entero  de tipo size_t
	strcpy(),strncpy()//copia un cadena de caracteres a otra
	strcat(),strncat() //Concatena una cadena con otra
	strcmp(),strncmp() //Compara una cadena de caracteres con otras
 #+END_SRC

 #+BEGIN_SRC C
	#include <stdio.h>
	#include <string.h>

	int main(){
	char myString[] = "myString";
		printf("The length of this str is: %d",strlen(myString));
		return 0;
	}

    char s[100];  //declaracion de la cadena
    s = "hello"; //inicializacion - NO funciona ("lvalue required" error)
    char scr[50], dest[50];
    //Copia los string sin chequear que cabe la cadena de caracteres
    strcpy(src,"This is source");
    strcpy(dest,"This is detination");
#+END_SRC

#+BEGIN_SRC C
  char src[40];
  char dest[12];
  //Ver como funciona memset
  memset(dest,"\0",sizeof(dest));
  //Copia los string limitando la cadena de caracteres
  strcpy(src,"This is source");
  strncpy(dest,src,10); 

    //Ejemplo de programa
    #include <string.h>
    int main(){
    char myString[] = "My name is Alejandro";
    char temp[50];
    strncpy(temp,myString,sizeof(temp) - 1); // aqui copia el maximo de la cadena -1 
											// (que es el espacio reservado para el elemento del escape de caracteres.)
    printf("The length is %d\n",strlen(myString));
    printf("The string is %s",myString);
    return 0;
    }
 #+END_SRC
	
 #+BEGIN_SRC C
  //Ejemplo de programa

  #include <string.h>
	int main(){
	  char scr[50], dest[50];
    //Copia los string sin chequear que cabe la cadena de caracteres
			strcpy(src,"This is source");
			strcpy(dest,"This is detination");
			strncat(dest,src,15); //copia en el arreglo destino(dest) hasta 15 caracteres de la cadena fuente (src)
			printf("La cadena final es: | %s |",myString);
    return 0;
    }
 #+END_SRC

 #+BEGIN_SRC C
   //No se puede compara un char con un char [] 
   //osea 'a' no se puede comparar con "a"

   //El comparador de la cadena de caracteres es strcmp y retorna un valor en dependencia de sin el valor es
   // si los valores son iguales retorna 0\
   // si str1 > str2 retorna valor > 0
   // si str1 < str2 retorna valor < 0
   // strcmp recibe un 3er parametro que limita la comparacion 
   // hasta la cantidad de elementos que se le paso como parametro 

	   printf("strcmp(\"A\",\"A\") is");
	   printf("%d\n",strcmp("A","A"));  //0

	   printf("strcmp(\"A\",\"B\") is");
	   printf("%d\n",strcmp("A","B"));  //-1

	   printf("strcmp(\"B\",\"A\") is");
	   printf("%d\n",strcmp("B","A"));  //1

	   printf("strcmp(\"C\",\"A\") is");
	   printf("%d\n",strcmp("C","A"));   //1

	   printf("strcmp(\"Z\",\"a\") is");
	   printf("%d\n",strcmp("Z","a"));   //-1

	   printf("strcmp(\"apples\",\"apples\") is");
	   printf("%d\n",strcmp("apples","apples")); //1 
	
	//Compara el primer elemento con el segundo hasta 5 caracteres
	   if(strncmp("astronomy","astro",5) == 0){
		   printf("Palabra astronomy encontra");
	   }

	   if(strncmp("astounding","astro",5) == 0){
			printf("Esto no se ejecutara \n");
			printf("porque no coinciden la cadenas.");
	   }
	

 #+END_SRC

*** DONE Buscando Tokenisando y analizando cadeneas de caracteres (Searching, Tokenizing, Analizing Strings)
	CLOSED: [2023-10-04 mié. 14:35]
	- Existen mas funcionalidades de cadenas de caracteres
	- Otras funciones my utilizadas son las funciones de busqueda en cadenas de caracteres 
	  y particionamiento de cadenas.
	- La funcion *strchr()* busca en una cadena de caracteres por un caracter especifico
		- El primer argumento a la funcion es un string que puede ser buscado con la direccion
		  del arreglo de la cadena de caracteres.
		- El segundo argumento es el caracter a buscar
		- La funcion buscara la cadena de caracteres al principio y retorna un puntero 
		  de la primera posicion de la cadena donde se encontro el caracter.
        - Se debe crear una variable de tipo *char* *** . para guardar el resulado de la funcion.
		- Si no se encuentra nada retorna *NULL* que es el equivalente a 0 en un puntero, indicando
		  que retorna a nada.
 #+BEGIN_SRC C
   #include <string.h>
   strchr();
   strstr();
 #+END_SRC
	
 #+BEGIN_SRC C
   // Descripcion de strchr()
   char str[] = "The quick brown fox";  // Cadena donde se va a buscar
   char ch = 'q';						 // Caracter que se buscando
   char *pGot_char = NULL;				 // Puntero inicializado a NULL
   pGot_char = strchar(str,ch);		 // almacena la direccion donde se encontro ch
   /*
	 -	EL primer argumento de strchr() es la direccion de la primera localizacion a buscar.
	 -	El segundo es el caracter que es buscado (sought) que es de tipo char.
	 -	Se espera un segundo argumento que sea de tipo int, por lo que el compilador,
	   lo convierte el valor de ch a este tipo.
	 - Tambien se podria haber definido a ch como tipo int (int ch = 'q';)
	 - pGot_char apuntara al valor ("quick brown fox")
   */	
 #+END_SRC
	- La funcion *strstr()* es la mas util de la funciones de busqueda
	   - Busca una subcadena dentro de una cadena de caracteres.
	   - Retorna un puntero a la posicion de la cadena donde se encontro 
	     la subcadena. 
	   - Si no escuentra retorna NULL.
		- El primer argumento es la cadena a donde buscar. 
		- El segundo argumento es la subcadena a buscar.	
	   - La funcion es *case sentitive*. Por lo que si se escribe "Dog" no sera encontrado.

 #+BEGIN_SRC C
	//Descripcion de la strstr(	)
   char texto[] = "Cada perro tiene sus dias"; // Texto donde se va a buscar
   char palabra[] = "perro";					// Palabra a buscar
   char *pFound = NULL;					    	// Puntero inicializado a NULL
   pFound = strst(texto,palabra);		           // Retorna un puntero de la primera position donde se encontro la palabar

   // La palabra perro aparace en el septimo caracter 
   // pFound se pondra en la direccion del texto + 6 ("perro tiene sus dias")
 #+END_SRC	


 #+BEGIN_SRC C
	#include <string.h>
   //Busca en la cadena el caracter deseado y devuelve el puntero      
   //de la posicion de el elemento que encontro, devuelve NULL si no encontro el caracter deseado. 
   char str[] = "Estoy cargando informacion que me ayude";
   char ch = 'c';
   char *elm = NULL;
   elm =	strchar(str,ch);

   // Busca en la cadena la palabra deseada y devuelve el puntero      
   // de la posicion de el elemento que encontro, devuelve NULL si no encontro el caracter deseado. 

   char str[] = "Estoy cargando informacion que me ayude";
   char mystr[] = "informacion";
   char *elm = NULL;
   elm =	strstr(str,mystr);
   //devuelve la cadena de caracteres de la palabra encontrada hasta el final de la cadena

 #+END_SRC

   TOKENIZANDO LAS CADENAS DE CARACTERES
	- Los token son sequencias de caracters dentro de una cadena atada 
	  a un *delimitador.*
	- Un delimitador puede ser cualquier cosa pero deberia ser una cadena unica.
      - espacios, commas, y puntos son ejemplos.
	- La funcion *strtok()* es usada para tokenizar una cadena de caracteres.
	  la cadena requiere dos argumentos.
	  - cadena de caracteres a tokenizar
	  - cadena que contiene todos los posibles caracteres delimitadores. 	

 #+BEGIN_SRC C  Ejemplo de subdivision la cadena de caracteres en tokens
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  int main()
  {
	  char str[80] = "(Hola me llamo-alejandro (que tal*estas) hoy.)";
	  const char s[10] = ")(";
	  char * token;
	  token = strtok(str,s);

	  while(token != NULL){
		  printf("%s\n",token);
		  token = strtok(NULL,s);
	  }
	  return 0;
  }

 #+END_SRC
 #+BEGIN_SRC C  Ejemplo 2 Divide la cadena en tokens 
	 strtok()
	 char str[] = "Hola alejandro-como estas hoy que-tal te va.";
	 char tok[] = "-";
	 char *token = NULL;
	 token = strtok(str,tok);
	 do {
	   printf("%s",token);
		   // strtok toma como referencia la cadena anterior por lo que si se quiere iterar 
		   // sobre la misma cadena se usa NULL, si se desea iterar sobre la nueva cadena 
		   // se le pasa la nueva cadena.
	 } while( (token = strtok(NULL,tok)) != NULL );

	   //Para analizar cadenas se usan las siguientes funciones las cuales retornan true o false, cuando resiven un 'CARACTER'.
	   char letter = 'd';
	   islower(letter) //Minuscula
	   isupper() // Mayuscula
	   isalpha() // Alfanumerico 0 al 9, de a hasta z
	   isalnum() // Muestra cualquier caracter del '0' al '9' y de la A a Z minusculas y mayusculas.
	   isdigit() // Muestra cualquier caracter del '0' al '9'
	   isxdigit()// Caracteres hexadecimal del '0' al '9' 'A' a 'F' y de  'a' a 'f'
	   iscntrl() // Muestra cualquier caracter  
	   isprint() // Muestra cualquier caracter 
	   isgraph() // Muestra cualquier caracter menos los espacios
	   isblank() // Muestra los caracteres en blanco y tabulador '\t'
	   isspace() // Muestra los caracteres que crean espacios en blancos como '\n' '\t' '\v' '\r' '\f'
	   ispunct() // Muestra los caracteres que no muestra isspace() e isalnum()

 #+END_SRC
	|------------+-----------------------------------------------|
	| Funcion    | Descriopcion                                  |
	|------------+-----------------------------------------------|
	| islower()  | Para minusculas                               |
	|------------+-----------------------------------------------|
	| isupper()  | Para mayusculas                               |
	|------------+-----------------------------------------------|
	| isalpha()  | Para mayusculas y minusculas                  |
	|------------+-----------------------------------------------|
	| isalnum()  | Para mayusculas y minusculas y numeros        |
	|------------+-----------------------------------------------|
	| isdigit()  | Digitos del '0' al '9'                        |
	|------------+-----------------------------------------------|
	| isxdigit() | Digitos hexadecimal '0' al '9', 'a' a la 'f'  |
	|            | y de la 'A' a la 'F'                          |
	|------------+-----------------------------------------------|
	| iscntrl()  | Caracter de control                           |
	|------------+-----------------------------------------------|
	| isprint()  | Cualquier caracter incluyendo el espacio      |
	|------------+-----------------------------------------------|
	| isgraph()  | Cualquier caracter excepto el espacio         |
	|------------+-----------------------------------------------|
	| isblank()  | Caracteres estandares en blanco (space, '\t') |
	|------------+-----------------------------------------------|
	| isspace()  | Caracteres de espacio en blanco               |
	|            | (space,'\n','\t','\v','\r','\f')              |
	|------------+-----------------------------------------------|
	| ispunct()  | Caracteres que las funciones isalnum() y      |
	|            | isspace() no muestran y retonan falso         |
	|------------+-----------------------------------------------|

 #+BEGIN_SRC C Ejemplo de tokenizadores

   #include <stdio.h>
   #include <string.h>
   #include <ctype.h>

   int main()
   {
	   //Variante 1
	   char buff[100];		//Buffer de entrada 
	   int nLetras  = 0;   //Numero de letras de la entrada
	   int nDigitos = 0;   //Numeros de digitos de entrada
	   int nPunct   = 0;   //Numero de caracteres de puntuacion
	   int i = 0;			//Indice del buffer

	   printf("Entre una cadena de caracteres de menos de %d caracteres\n",100);
	   scanf("%[^\n]",buff);
	   while(buff[i]){
		   if(isalpha(buff[i]))
			   ++nLetras;               // Incrementa el numero de letras 
		   else if(isdigit(buff[i]))
			   ++nDigitos;			     // Incrementa el numero de digitos
		   else if(ispunct(buff[i]))
			   ++nPunct;			     
		  printf("%c",buff[i]);
	   ++i;
	   }
	   printf("Hubo %d iteraciones\n", i);
	   printf("\n Su cadena contiene %d letras, %d digitos, %d caracteres de puntuacion \n",nLetras,nDigitos,nPunct);	
	   return 0;


	   //Variante 2
	   //Se repite las los mismas variables de la variante anterior
	   char letra;
	   printf("Entre una cadena de caracteres de menos de %d caracteres\n",100);
	   scanf("%[^\n]",buff);
	   while((letra = buff[i]) != '\0'){
		   if(isalpha(letra)){
			  printf("%c",letra);
			  ++nLetras;
		   }
		   // Incrementa el numero de letras 
		   else if(isdigit(letra)){
			  printf("%c",letra);
			  ++nDigitos;			     // Incrementa el numero de digitos
		   }
		   else if(ispunct(letra)){
			  printf("%c",letra);
			  ++nPunct;
		   }
		   ++i;
	   }

	   printf("\n Su cadena contiene %d letras, %d digitos, %d caracteres de puntuacion \n",nLetras,nDigitos,nPunct);	
	   return 0;



 #+END_SRC

*** DONE Convirtiendo cadenas de caracteres (Converting Strings)
	CLOSED: [2023-10-03 mar. 08:14]

   - Para convertir los caracteres en de minuscala a mayuscula y viceversa se usan las siguientes funciones: 

 #+BEGIN_SRC C

   toupper();  // Convierte caracteres a mayuscula
   tolower();  // Convierte caracteres a minuscula
   int a = 47;

   // 1- Ambas funciones devuelven un entero despues hay que convertirlos a char (char)a
   // 2- Las funciones anteriores mantienen o convierten en mayuscula o minuscula según la función 
   // y  devuelven los signos de puntuacion intactos.

   char buffer[50] = "Hola alejandro esta cadena la voy a convertir en mayuscula.";

   for(int i = 0;(buffer[i] = (char)toupper(buffer[i])) != '\0' ;i++);

	// Se puede usar la funcion toupper() en combinacion con strstr() 
	// cuando un caracter aparece en otro caracter.

 #+END_SRC

 #+BEGIN_SRC C
   char text[100];     //input buffer for string to be search
   char substring[40];	//input buffer for string sought

   printf("Inserte la cadena a buscar (menos de %d caracteres): \n",100);
   scanf("%s",text);


	printf("\nInserte la cadena a cambiar (menos de %d caracteres): \n",40);
	scanf("%s",substring);



	printf("La primera cadena es :\n%s\n",text);
	printf("La segunda cadena es :\n%s\n",substring);


   //Convertir ambas cadenas mayuscula.
   for(int i = 0;(text[i] = (char)toupper(text[i])) != '\0' ;i++);
   for(int i = 0;(substring[i] = (char)toupper(substring[i])) != '\0' ;i++);


   printf("La segunda cadena %s encontrada en la primera\n",((strstr(text,substring) == NULL ) ? "no fue" : "fue"));

 #+END_SRC
	
	
	- En la biblioteca estandar *stdlib.h* estan declaradas funciones 
	  que se pueden usar para convertir cadenas de caracteres a valores númericos

 #+BEGIN_SRC C
   char value_str[] = "98.4";
   double value = atof(value_str);
 #+END_SRC	
	  
    - En las siguientes funciones el espacio en blanco es ignorado.
	|-----------+----------------------------------------------------------------|
	| Funciones | Retorna                                                        |
	|-----------+----------------------------------------------------------------|
	|           | Un valor de tipo double que es producido                       |
	|           | por un argumento de tipo cadena de caracteres.                 |
	|           | Infinity como valor *double* es reconocido                       |
	| atof()    | de las cadenas "INF" o "INFINITY" donde  cualquier caracter    |
	|           | puede ser mayuscula o minuscula y "not a number" es reconizido |
	|           | como la cadena "NAN" en minuscula o mayuscula.                 |
	|-----------+----------------------------------------------------------------|
	|           | Un valor de tipo *int* que es producido por argumento de         |
	| atoi()    | una cadena de caracteres.                                      |
	|-----------+----------------------------------------------------------------|
	|           | Un valor de tipo *long* que es producido por argumento de        |
	| atol()    | una cadena de caracteres.                                      |
	|-----------+----------------------------------------------------------------|
	| atoll()   | Un valor de tipo *long* *long* que es producido por argumento de   |
	|           | una cadena de caracteres.                                      |
	|-----------+----------------------------------------------------------------|
	
	- Las siguientes funciones se convierte de cadenas de caracteres (string) a numero

	|-----------+--------------------------------------------------------------------|
	| Funciones | Retorna                                                            |
	|-----------+--------------------------------------------------------------------|
	|           | Un valor de tipo *double* que es producido                           |
	|           | por un argumento de tipo cadena de caracteres.                     |
	|           | El segundo argumento es un puntero a una variable ptr              |
	| strtod()  | de tipo *char** en el que la funcion almacenara la direccion         |
	|           | de la primer caracter siguiendo el substring que fue convertidad a |
	|           | *double.* Si la cadena no se encuentra la variable ptr contendra     |
	|           | la direccion de que se les paso como primer.                       |
	|-----------+--------------------------------------------------------------------|
	| strtof()  | Un valor de tipo *float.*  Todo lo demas es igual que strod()        |
	|-----------+--------------------------------------------------------------------|
	| strtold() | Un valor de tipo *long double.*  Todo lo demas es igual que strod()  |
	|-----------+--------------------------------------------------------------------|
	
  - Ejemplo de funciones de convercion de cadena a numeros

 #+BEGIN_SRC C
   double value = 0;
   char str[] = "3.5 2.5 1.26"; // La cadena de caracteres a ser convertida
   char *pstr = str;     		 // Puntero a la cadena a ser convertida 
   char *ptr = NULL;     		 // Puntero a la posicion del caracter despues de la convercion
   int total = 1;
	while(true){
		value = strtod(pstr,&ptr); // pstr es la cadena completa, &ptr es la direccion del puntero a la cadena .
								   // si no se pone & clangd dira que se debe pasar un dato de tipo char** 
								   // porque el parametro que recibir es una direccion de un puntero de tipo char.
		if(pstr == ptr)            // Almaceno pstr si no hay conversion
			break;
		printf("Cadena restante %s numero %d \n",pstr,total++);
		printf(" %f",value);   // La salida resultante 
		pstr = ptr;     

	}

 #+END_SRC

*** DONE Desafio Entendiendo cadenas de caracteres (Challenge Understanding char array)
	CLOSED: [2023-10-05 jue 07:07]
	Escribir dibversas funciones que manipulen los arreglos
	  - La primera funcion deben contar el numero de caracteres en la cadena
	  - no se pede usar la funcion *strlen*  
	  - debe retornar in entero
	
	  - la segunda funcion debe concatenar dos cadena de caracteres
	  - no se puede usar la funcion *strcat*
	  - la funcion resive tres parametros
		- char result[]
		- const char str1[]
		- const char str2[]
		- pude retornar void

	  - La tercera funcion determina si dos cadenas son iguales
		- no se puede usar la funcion strcmp
		- la funcion resive como parametro dos const array y retorna un boolena 

 #+BEGIN_SRC C
	#include <stdio.h>
	#include <string.h>

	int count_char(const char[]);
	void concatenate_chars(char[],const char[],const char[]);
	_Bool they_are_equal(const char[],const char[]);

	int main()
	{
		char str1[] = "Hola mundo";
		char str2[] = "como estas";
		char result[100];

		return 0;
	}

	int count_char(const char str[]){
		int i = 0;
		while (str[i] != '\0') i++;
		return i;
	}

	void concatenate_chars(char result[],const char str1[],const char str2[]){
		int i,j;
		for ( i = 0;str1[i] != '\0' ; ++i) 
			result[i] = str1[i]; 

		for (j = 0; str2[j] != '\0'; ++j) 
			result[i + j] = str2[j];

		result[i + j] = '\0';
	}

	_Bool they_are_equal(const char str1[],const char str2[]){
		int i = 0;
		while (str1[i] == str2[i] && str1[i] != '\0' && str2[i] != '\0') i++;

		if(str1[i] != '\0' && str2[i] != '\0')
			return 1;
		return 0;
	}
 #+END_SRC

*** DONE Desafio utilizando las funcione string comunes (Challenge Utilizing common string functions)
	CLOSED: [2023-10-07 sáb 20:56]
	Escribir una funcion que capture una cadena por entrada y la muestre al reves
	- Se necesita la funcion *strlen* 

   Escriba una funcion que ordene las cadenas 
	- Se usara las funciones strcmp y strcpy
	ejemplo: 
	Entra numeros de cadenas: 3
	Entrar string: 3
	- zero
	- one
	- two

	Salida de las cadenas despues de ordenamiento
	- one
	- two
	- zero
#+BEGIN_SRC C Respuesta de la primera funcion
	#include <string.h>

	char str1[] = "Hola mundo";
	char str2[11];
	int i = 0 ,j = 0;
	int len = strlen(str1);
	for (j = len - 1,i = 0; i < len;i++,j--)
		str2[i] = str1[j];

	str2[i] = '\0';
	printf("%s\n",str2);

#+END_SRC

 #+BEGIN_SRC C Respuestas de la segunda funcion
   #include <stdio.h>
   #include <string.h>
   #include <ctype.h>

   int main()
   {

	   char cadenas[5][100]; // Para guardar cadenas [5] son la cantidad de string a guardar y
						   // [100] la longitud de los string a guardar
	   char temp[25];
	   int i = 0,n = 5,j;

	   printf("Escriba 5 string a ordenar: \n");
	   for(int i = 0; i < n; i++) 
	   scanf("%s",cadenas[i]);



	   for(i = 1; i <= n;i++){ 
		   for(j = 0;j <= n - i;j++ )
		   if(strcmp(cadenas[j],cadenas[j+1])>0){
			   strncpy(temp,cadenas[j],sizeof(temp) - 1);
			   strncpy(cadenas[j],cadenas[j +1],sizeof(cadenas[j]) - 1);
			   strncpy(cadenas[j + 1],temp,sizeof(cadenas[j + 1])- 1);
		   }
	   }

	   for (int i = 0;i < 5; i++) 
		   printf("%s\n",cadenas[i]);

	   return 0;
   }

 #+END_SRC

** DONE Debugging [5/5]
   CLOSED: [2023-10-18 mié 22:56]
*** DONE Resumen Overview
	CLOSED: [2023-10-07 sáb 23:53]
	RESEÑA BASICA
		- *Debuggear* es el proceso de encontrar y arreglar errores
		(usualmente errores logicos, que tambien incluyen errores de compilacion / sintasix)
			- Para errores de sintasix, es necesario entender lo que el compilador 
			intenta decirte
			- Siempre hay que enfoncarse en el primer problemas detectado.
			- La habilidad de debuggear es esencial para un programador puede disminuir la cantidad
			la cantidad de dinero, ya que la etapa de mantenimiento es la mas costosa
	PROBLEMAS COMUNES
	    - Errores logicos  
		- Errores de Sintaxis
		- Corrupcion de memoria
		- Escalabilidad y rendimiento (Performance)
		- Falta de cohesion 
		- Acoplamiento ajustado (uso de dependencias)  

	PROCESO DE DEBUGUEO
		- Entender el problema(sentarse con el tester y entender los requerimientos)
		- Reproducir el problema 
		  - A veces es dificil detectar los problemas porque son intermitentes 
			y solo pasan muy rara vez.
	      - Problemas multihilo y paralelo.
		- Simplificar el problema / Divide y Venceras / Aislar la fuente
		  - Eliminar parte del caso de uso original de prueba
		  - Commentar y descomentar el codigo 
		  - Convertir un programa de en muchos pequenios programas (Pruebas unitarias)
	    - La resolucion de errores sera mediante practica y prueba.
		- Algunas veces incluye el rediseño o refactorizacion de codigo.  
	TECNICAS Y HERRAMIENTAS 
		- Traceo y uso de declaraciones print
		  - Muestro el fujo de ejecucion
		  - Salida de valores de variables en partes del programa.
		- Uso de debugger para monitoriar la ejecucion del programa,detenerlo
		  reiniciarlo, poner puntos de rupturas y mirar variables en memorias.
		- Archivos de logs pueden ser usados para adicionar declaraciones en el codigo.
		- Monitorio de software en tiempo de ejecucion, trafico de redes, hilos e 
		  informacion de objetos.
	HERRAMIENTAS COMUNES DE DEBUGUEO
	    - Analizadores estaticos 
	       - Analizar el codigo fuente por un set especifico de problemas conocidos. 
		   - Chequeo de semantica.
		   - Puede detectar variables no inicializadas, fuga de memorias,
			 codigo inalcanzable, abrazo fatal, condiciones de carrera. 
		- Suites de pruebas
		   - Corre un set de comprencion de sistemas de pruebas punto a punto.
		- Debugear el programa despues de crahshearse 
		   - Analiza la pila 
		   - Analiza la (memory dump) el archivo fuente.
	PREVENIR ERRORES 
		- Escribir codigo de gran calidad siguiendo buenos principios de diseño y buenas 
		 practicas.
		  - Pruebas unitarias, con ejecucion automaticas cuando compilen
		  - Encontrar errores en el codigo nuevo antes de entregarlo 
		  - TDD (Test Driven Development) Desarrollo Orientado a Pruebas
		  - Producir buena documentacion y desarrollar una buena planificacion y apropiado seudocodigo
		  - Evitar hacer muchos cambios a la vez 
			- Cuando hagas cambios aplicalos de manera incremental. Realiza un cambio 
			  realiza un test y luego pruebalo para hacer el proximo paso. Este forma
			  de desrrollado ayuda a reducir la fuente de errores y limita los problemas.
*** DONE Entendiendo la llamada a la pila (Understanding the call stack)
	CLOSED: [2023-10-16 lun 20:18]
	RESUMEN 
	- Un rastro de la pila(*stack trace*) se genera cada vez que se crashea el software.
	- EL stack trace muestra una lista de llamadas de funciones que conducen 
	  al error.
	- Esto incluye nombre de archivos y linea de codigo donde se produjo el error.
	- En la punta de la pila esta la ultima llamada que causo el error(nested calls)
	- En el fondo de la pila contiene la primera llamada que comenzo la cadena de 
	  eventos que causaron el error. 
    - Nesecitas encontrar en la llamada de la aplicacion lo que esta causando el crash.
   - La pila de llamada se genera cuando la aplicacion se crashea debido a una error fatal
	 - El traceo de la pila es una litas de llamadas de funciones que conducen al error 
	   - El traceo de la pila incluye archivos y lineas de codigo donde se puede encontrar
		 errores o exepciones que puedan ocurrir.
	   - La punta de la pila contiene la ultima llamada que causo el error en las 
		 llamadas anidadas. 
	   - En el fondo de la pila se encuentra la primera llamada que comenzo la cadenas
		 de llamadas que causo el error.
	   - Se necesita encontrar la llamada que causa el error.
	 - El programador puede desechar la pila de traceo.
*** DONE Code Blocks debugger 
	CLOSED: [2023-10-16 lun 20:18]
	- EL codigo de esta session se visualiza en el editor de code blocks
*** DONE Common C Mistakes
	CLOSED: [2023-10-17 mar 22:04]
	Existen una variedad de errores comunes en c que se deben tomar encuenta.

	MAL POSICIONAMEINTO DEL PUNTO Y COMA
	 - Un ejemplo es poner un ; en las codicinales de una sola linea
	 - EL valor de j siempre sera 0 devido al posicionamiento del punto y coma 
	   despues cerrar el parentesis.
	 - Es sintacticamente valido (es una declaracion de null) por lo que no se
	   produce error al compilar.
	 - El mismo tipo de errores se produce al usar while y for.
	#+BEGIN_SRC C
		if(j == 100); //Aqui no se pone ;
			j = 0 
	#+END_SRC

	CONFUNDIR EL OPERADOR = WITH == OPERATOR
	- Usualmente sucede dentro de las declaraciones if, while, o do-while 
	- El siguiente es un caso valido y tiene el efecto de asignar 2 en *a* y luego ej
	   ejecutar la llamada de printf()
	- En el caso de printf se ejecuta siempre la llamada de printf 
	- Printf siempre sera llamada porque el valor contenido en la expresion siempre 
	  sera no cero.
	#+BEGIN_SRC C
	  if(a = 2)
	   printf("Siempre me invocaran");
	#+END_SRC

	OMITIR LAS DECLARACIONES DE PROTOTIPOS 
	- Si se invoca una funcion cualquiera en un archivo diferente y no es 
	  explicitamente declarado el compilador que se retrona un int
	- Es necesario declarar el prototipo de la de todas las funciones que se 
	  invoquen explicitamente por el programador o enplicitamente incluyendo 
	  los archivos de cabecera correspondientes.
	 
	NO INCLUIR LOS HEADER FILES QUE INCLUYEN LAS DEFINICIONES PARA UNA BIBLIOTECA 
	QUE SERA USADA EN EL PROGRAMA.
	
	- Si el programa no incluye la etiqueta *#include <math.h>* esto generara un error 
	porque la funcion sqrt() esta indefinida.

   #+BEGIN_SRC C
	  double answer = sqrt(value);
   #+END_SRC

	CONFUNDIR UNA CONSTANTE DE CARACTERES CON UNA CADENA DE CARACTERES
	
   #+BEGIN_SRC C
	 char text = 'a'; // Es un caracter asignada a una variable texto
		 text = "a"; // Un puntero a una cadena de caracteres "a" es asignada a text

	// En el primer caso se declara la variable text se declara como char 
    // En el segundo caso deberia ser declarado como puntero de tipo char

   #+END_SRC

	USAR LOS LIMITES INCORRECTOS PARA INICIALIZAR UN ARREGLO
	 - La declaracion del limite del ciclo a continuacion es incorrecta debe terminar 
	   en 99 y no 100. Lo correto seria i < 100.
	 - Tambien deberia empesar en el principio del arreglo o sea el indice 0 por lo
 	   que i deberia ser 0.
	 - Este tipo de errores se aplica a las cadenas de caracteres cuando no se reserva 
	   espacio suficiente en las cadenas de caracteres, cuando se declara un arreglo.

	#+BEGIN_SRC C
	  int arr[100]; i, sum = 0;
	  for(int i = 1; i <= 100;i++)
		  sum += arr[i];

	char saludo[4] = "Hola";  // No se reservo espacio para el null terminator( '\0' ) el
							  // Al final de la cadena por lo que dara error.
	#+END_SRC

	CONFUNDIR EL OPERADOR -> CON EL OPERADOR . CUANDO SE ESTA REFENCIANDO A
	MIEMBROS DE UNA ESTRUCTURA
	- El operador . es usado para variables de una estructura.
	- El operador -> es usado para variables punteros de una estructura.

	OMITIR EL AMPERSAND ANTES  DE VARIABLES NO PUNTEROS EN UNA LLAMADA SCANF()

	- Todos los argumentos que aparece despues del formato de scanf deben ser punteros.
    #+BEGIN_SRC C
		int number;
		scanf("%i",number); // Esta llamada a number es incorrecta, si se usa
							//	una variable que no es un arreglo se usa &nombre_variable
    #+END_SRC
	
	(MUY IMPORTANTE) ASIGNAR UN VALOR A UNA VARIABLE PUNTERO ANTES DE SER INICIALIZADO EL PUNTERO 

	- Solo se puede aplicar operador de indireccion de un puntero a una variable despues de que 
	  se asigne a una direccion de memoria al puntero en cuestion.
	- En el siguiente ejemplo char_pointer nunca se asigno a nada por lo que la 
	  asignacion no es significa.
	
    #+BEGIN_SRC C
		char *char_pointer;
		*char_pointer = 'X';  //Esto causara error de memoria (segmentacion fault) al compilar
    #+END_SRC

	OMITIR LAS DELCARACIONES DE BREAK EN LOS CASE DE LOS SWITCH
	- Cuando no se incluye los break en un case de un switch este pasara al siguiente
	  case. 
	INSERTAR UN PUNTO Y COMA EN LA DEFINICION DE UN PREPROCESADOR 

	- Suele ocurrir ya que se inserta por cuestion de habitos de terminar todas las
	  declaraciones con punto y coma.
	
	#+BEGIN_SRC C
		#define END_OF_DATA 999; // Esta declaracion lleva a error en la espancion de macros
		if(value == END_OF_DATA)	
		
		
		if(value == 999;)       //Como el macro se intercambia por la definicion queda 999;
								//que es como se definio	

	#+END_SRC

	OMITIR CIERRE DE PARENTESIS Y OTROS SIMBOLOS DE CIERRE COMO DOBLE COMILLAS EN LOS STRINGS
	- La falta de comillas o parentesis dara error de compilacion.
    #+BEGIN_SRC C
		total = (cash + (investment * interest_investment) + ( saving * saving_investment); //Falta parentesis de cierre.
		printf("Tu dinero es de %.2f,total);   //En este caso falta la doble comilla despues de 2f.	 
    #+END_SRC

*** DONE Undertanding C Errors (Entendiendo los errores en C)
	CLOSED: [2023-10-18 mié 22:55]
	- Es necesario entender que es lo que el compilador indica en caso de error
	  ya que hace complicado identificar la verdadera razon detras del mensaje	
	  de los errores de compilacion.
	- El compilador toma deciciones de como se traduce el codigo que el
	  que el programador no ha escrito aun. Es conveniente porque los programas 
	  pueden ser escritos mas compactos, solo los programadores expertos toman 
	  ventajas de esto.
	- Se deberia usar la opcion *-Wall* donde el compilador notifica todos los 
	  casos donde las deciciones son implicitas.
	
	El compilador muestra dos tipos de problemas:
	*ERRORES*  
	  - Es una condicion que previene la finalizacion de la creacion del programa.
	  - No ejecutable es obtenido hasta que todos los errores han sido corregidos 
	  - Los primeros errores mostrados son mas precisos, ya que los que le siguen
		se pueden derivar de los anteriores.
	  - Se recomienda arreglar los primeros errores y recompilador porque a veces 
		los errores que preceden pueden ser derivados de los errores anteriores.

	WARNINGS 
	  - Los mensages del compilador muestra acerca de cualquier situacion especial
		en donde una anomalia es detectada.
	  - Son considerados errores no fatales.
	  - El ejecutable final del programa se puede obtener con cualquier numero de 
		advertencia.
	  - Al compilar con la opcion *-Wall* no se considera que el programa es correcto
		hasta que hasta que todas las advertencia han sido eliminadas.

	ERRORES MAS COMUNES
	*Variable* no declarada
	  - Este es uno de los errores mas comunes de y faciles de detectar.
	  - El simbolo mencionado al principio del mensaje es usado pero no declarado.

	*Warning* declaracion implicita de funcion
	  - Esta advertencia aparece cuando el compilador encuentra una funcion
		que es usada en el codigo, pero no hay informacion previa creada.
	  - Se necesita declarar el protoitipo de la funcion.

	*Warning* El contro alcanzo en fin de una funcion no vacia
	  - Esta declaracion aparece cuando una funcion ha sido definida como retorno
		de un resultado pero la declaracion de retorno no ha sido includo en este
		resultado. 
	  (Oracion exacta)
	  - this warning appears when a function has been defined as returning a result but
		no return statement has been include to return this result.
	  - La funcion esta incorrectamente definida or la declaracion no esta definida 

	*Warning* variable no usada
	  - Esta advertencia se muestra cuando una variable es creada pero no usada en el
		codigo.
	  - El mensage desaparece si la declaracion es eliminada.

	*Warning* referencia indefinida a
	  - Aparece cuando hay una funcion invocada en el codigo que ha no sido definida
		en ninguna parte del codigo.
	  - EL compilador muestra que hay una definicion de una funcion sin definicion.
	  - El compilador chequea que la funcion esta perdida y se asegura que la definicion
		se compila.
	*Error* conflictos de tipos en:
	Dos definiciones de funciones han sido encontradas:
	  - Una es el prototipo de la funcion (el tipo de resultado, nombre, incluyendo
		parentesis, y los puntos y comas)
	  - la otra es la definicion en el cuerpo de la funcion.
	  - La informacion en ambos lugares no es identica y conflictos han sido detectados.
	  - EL compilador muestra en que linea el conflicto aparece y las definiciones
		previas que causan la contradiccion.


	ERRORES EN TIEMPO DE EJECUCION
	La ejecucion de un programa en C puede terminar abruptamente (crash) cuando
	un error en tiempo de ejecucion es detectado.

	 - Los programas en C solo muestran mensages escuetos de ( Segmentation Fault ) 
	 - Usualmente resulta enubn archivo central(core) que depende una senial
	   que ha sido lansada
	 - Se puede analizar el archivo central(core) y la pila de llamadas (call stack).
	   
** DONE Pointers [17/17]
CLOSED: [2023-11-26 dom 11:12]
*** DONE Resumen (Overview)
CLOSED: [2023-10-31 mar 07:30]
	- El concepto de indireccion es la habilidad de referenciar algun elemento usando 
	  el nombre, referencia, o contenedor, en vez de un valor en si.
	- EL PUNTERO ALMACENA DIRECCIONES DE MEMORIA DEL TIPO QUE SE CREA.
	- La forma mas comun de indireccion es manipular el valor de las variables atravez
 	  de las direcciones de memoria.
	- El puntero provee un medio indirecto para acceder el valor deseado.
	- Los punteros de un tipo solo pueden acceder a un tipo de datos que estan apuntando ejemplo
	  - Los punteros de tipo int solo pueden acceder a variables de tipo int.
	  - Los punteros de tipo float solo pueden acceder a variables de tipo float ect.
	- Con el simbolo *&* delante de una variable que no sea puntero se accede a su direccion de memoria
	- Se puede accceder al a direccion del puntero con *&*.		  
	- Con los punteros se puede acceder a las direcciones de memoria y puedes tratarlas como variables
	  y realizar aritmetica de punteros.
	- Los punteros te permiten acceder a los mismos espacios de memoria desde diferentes localizaciones.
	- Permiten ahorra espacios compartiendo componentes en tus estructuras de datos.
	- Se puede pasar datos a las funciones con los punteros como llamadas por referencias donde los
	  punteros evitan que se cree nuevas variables en el *scope* de la funcion usando menos memorias
	  de la que se necesita.
	PORQUE USAR PUNTERO
	 - Los punteros permiten obterner multiples valores de las funciones.
	   las funciones solo pueden retornar un valor, pero pasar mas de un valor como argumento como puntero
	   podemos obtener mas de un valor de las funciones.
	 - Con los punteros se puede crear memoria dinamica de acuerdo con el uso en el programa.
	   Podemos salvar espacio de memoria de tipo estatica con declaraciones (en tiempo de compilacion).
	 - Los punteros nos permite crear estructuras de datos complejas como pilas, colas, listas ect.
	 - Provee un accedo directo a la memoria.
*** DONE Definir punteros (Defining Pointers)
CLOSED: [2023-10-31 mar 07:30]
    - Los punteros se inicializan con la direccion de las variables antes declaradas.
    - Los elementos como NULL o escape de cadenas de caracteres ('\\0') son considerados elementos falsos dentro de un ciclo if o while.
	- LOS PUNTEROS ALMACENAN DIRECCIONES DE MEMORIA DE OTRAS VARIABLES.
	- Se puede inicializar el puntero en NULL garantizando que no se apunte a ninguna direcion de memoria.
	  Esto implica la prevencion implicita de sobre escritura de memoria usando punteros que no apuntan a nada especifico. 
	- Para usar NULL se debe incluir la biblioteca <stddef.h>
	- Si se quiere inicializar una variable con una variable ya inicializada se usa el operador *&*.
		- Se debe declarar la variable que contiene el valor antes de guardar la direccion en el puntero como se 
		  muestra a continuacion.
    - Se debe tener cuidado en la declaracion del puntero porque declarar en una linea varias variable sin usar * delante de ellas
	  puede ser confundido por el usuario y provocar errores en la asignacion de parametros.
#+BEGIN_SRC C Declaracion de un puntero

  #include <stdio.h>

  int main(){
	  int num = 3;
	  int *pnum = &num;  // & Address of Operator
	  printf("EL valor de num es %d\n",num);
	  printf("EL valor de pnum es %d\n",*num);

	  return 0;
  }

#+END_SRC

#+BEGIN_SRC C
	// CUIDADO aqui solo se declaro como puntero a *ptr2, demas elementos son variables
    // de tipo int
	int ptr, *ptr2,ptr3;
#+END_SRC


   - Se puede inicializar los punteros en null incluyendo la bibloioteca.

#+BEGIN_SRC C
  #include <stddef.h>

  int *ptr1,*ptr2;   //Declaracion de punteros de tipo int
  int *pnum  = NULL; //Es equivalente a zero 
  int *pnum2 = 0;    //Tambien se puede inicializar con 0 que es igual que decir NULL

#+END_SRC

*** DONE Acceder a punteros (Accessing Pointers)
CLOSED: [2023-10-31 mar 07:30]
  - Para obtener el valor de una variable a travez de un puntero se usa el operador de indireccion *.
  - Para acceder a la direccion de un puntero se puede usar el simbolo de direccion (&). Para evitar advertencia del compilador se pone delante de la direccion el operador void.
  #+BEGIN_SRC C
	char letra = 'a';
	char *pletra = &letra;
	printf("El valor del puntero es %p\n", pletra); 
	printf("La direccion del puntero es %p\n", &pletra); 
	printf("El valor de letra es %c\n",*pletra); 

	printf("El valor del puntero de es %p\n",(void*) &pletra); // Para obtener la direccion del puntero 
  #+END_SRC

  - El cast de (void * ) en el ultimo ejemplo previene posibles advertencia del compilador.
	La especificacion %p espera el valor de algun tipo de puntero pero el tipo de *&pletra* 
	es un "puntero a puntero int".

  #+BEGIN_SRC C Ejemplo de uso de indireccion
	int  number  = 5;
	int *pnumber = &number;
	int result   = 0;
		
	result = *pnumber + 5;  // *pnumber accedera a la direccion de number y
							// si desreferenciar par sumarle 5 y almacenarlo
							// en result
	printf("El valor final es %d",result);		

  #+END_SRC
  
   - Los punteros reservan espacios de 8 bytes, las direcciones de los punteros son de 16 digitos hexadecimales.
    1. Si el sistema operativo es de 64 bit y el compilador lo permite los punteros seran de direcciones de 64 bit.
    2. Algunos compiladores solo soportaran direcciones de 64 bit
   - Para saber el tamaño de los punteros se usa el sizeof pero tiene que hacer typecast o utilizar el operador "%zd"
	#+BEGIN_SRC C
		int number = 5;
		int *pnumber = &number;

		printf("El tamanio del puntero de es %d\n",(int)sizeof(pnumber)); 
		printf("El tamanio del puntero de es %zd\n",sizeof(pnumber)); 
	#+END_SRC

- Ejemplo de como pasar doble puntero por una funcion
 
	#+BEGIN_SRC C

  #include <stdio.h>
  #include <stdlib.h>

  void get_ptr_add(int **var){

	  printf("%p la direccion del puntero \n", var);
	  printf("%p es la direccion a la que apunta el puntero\n", *var);
	  printf("%d es el valor de la variable \n", **var);
  }

  int main(){
	int a = 10; 
	int *ptr = &a;
	
	printf("%p es la direccion del puntero \n", &ptr);
	printf("%p es la direccion a la que apunta el puntero \n", ptr);
	printf("%p es la direccion de la variable a \n", &a);
	printf("%d es el valor de la variable \n", a);
	printf("%d es el valor de la variable atravez del puntero \n\n", *ptr);
	get_ptr_add(&ptr);
  
	 return 0;
  }
	
	#+END_SRC
#+BEGIN_SRC C

  int main(){
	int number = 0;			//Variable de tipo int inicializada a 0
	int *pnumber = NULL;	//Un puntero que puede apuntar a un tipo int

	number = 10;
	printf("number's address: %p \n",&number);  //Salida de la direccion
	printf("number's value: %p \n",number);  //Salida del valor

	pnumber = &number; 						//Almacena la direccion de number en pnumber

	printf("pnumber's address: %p \n",(void *)&pnumber);     // Salida del valor
	printf("pnumber's size: %zd bytes \n",sizeof(pnumber));  // Salida de size
	printf("pnumber's value: %p \n",pnumber);  				 // Salida del valor(Una direccion)
	printf("value pointed to: %d \n",*pnumber);  		     // Valor de la direccion

	return 0;
  }
#+END_SRC

*** DONE Desafio Uso basico de punteros(Challenge Pointer Basic)
CLOSED: [2023-10-31 mar 07:30]
#+BEGIN_SRC C
	#include <stdio.h>
	#include <stdlib.h>

	int main()
	{
		int number = 10;
								//El siguiente paso se puede eliminar usando la sintasis commentada de abajo
		int *pnumber = NULL;	//int *pnumber = &number;  
		pnumber = &number;
	
		printf("El valor de la variable number atravez de pnumber es: %d \n",*pnumber);
		printf("La direccion de la variable number es: %p \n",&number);
		printf("La direccion de la variable number atravez de pnumber es: %p \n",pnumber);
		printf("El valor de la variable pnumber es de: %p \n",pnumber);
		printf("La direccion de la variable pnumber : %p \n",(void *)&pnumber);
		printf("La direccion de la variable pnumber sin el void es: %p \n",(void *)&pnumber);

		return 0;


	}

#+END_SRC

*** DONE Usando punteros (Using Pointers)
	CLOSED: [2023-10-31 mar. 09:08]
	- Se ofrece varias operaciones para trabajar con punteros
	  Se puede asignar una direccion a un puntero, el valor asignado puede ser un
	  nombre de arreglo, una variable que precede al operador (&) u otro puntero.
	- Se puede usar el operador de dereferencia (*)
      El operador (*) entrega el valor almacenado en la direcion a la que se esta 
	  apuntando.
	- Se puede obtener la direccion del puntero en si 
	  Si se desea obtener la direccion del puntero se pone delante de este el 
	  operador (&).
	- Se puede realizar aritmetica de punteros 
	  - Si se usa el operador *+* se puede adicionar un entero a un puntero, o un puntero 
		a un entero (El entero es multiplicado por el numero de bytes del valor apuntado 
		y adicionado al direccion original).
	  - Incrementar el puntero por uno (util en arreglos cuando se mueve al proximo elemento.)
	  - Si se usa el operador *-* se puede restar un entero a un puntero, o un puntero 
		a un entero (El entero es multiplicado por el numero de bytes del valor apuntado 
		y sustraido de la direccion original).

	  - Se puede encontrar diferencias entre dos punteros
	 	- Se puede hacer esto con dos punteros que se encuentran en el mismo arreglo para saber 
		  que tan distantes estan unos de los otros.
	 - Se pueden comparar dos punteros para saber (deben ser del mismo tipo)
	 - Se puede hacer dos formas de substraciones:
		- Se puede substraer un puntero de otro puntero para obtener un entero. 
		- Se puede substraer un entero de otro puntero para obtener un puntero.
	- SE DEBE TENER CUIDADO CON EL INCREMENTO Y DECREMENTO DE LOS PUNTEROS
	  El sistema no tracea donde esta el puntero localizado en un arraglo por lo que podria
	  dar error de limites.
	PUNTERO EN EXPRESIONES 
	- El valor usado por un puntero puede ser usado en expresiones aritmeticas
	  Si la variable es definida para ser de tipo _puntero a entero_ entonces es evaluada usando las 
	  reglas de aritmetica de enteros.
#+BEGIN_SRC C
  int main(){
	  int number = 10;      // Variable de tipo int inicializada en 0;
	  int *pnumber = NULL;  // Un puntero que puede apuntar a un tipo int
	  number = 10;
	  pnumber = &number;    // Almacena la direccion del numero en pnumber
	  *pnumber += 25;		// Le suma 25 a number atravez de la indireccion de pnumber

  }
#+END_SRC
	- En el ejemplo anterior se incrementa en 25 al valor de number 
	  - * indica que estas accediendo al contenido a la cual la variable llamada pnumber
		esta apuntando.
	- Si un puntero apunta a una variable *X*
	  - El puntero fue definido para ser un puntero de tipo de dato que la variable *X* 
	  - Usar la expresion **puntero* es identico a decir *X* en la expresion en cuestion.

	- Se puede usar el tipo puntero para cambiar varias variables, mientras estas 
	  tengan el mismo tipo del puntero.
#+BEGIN_SRC C
  int main(){
	long num1 = 0l;
	long num2 = 0l;
	long *pnum = NULL;

	pnum = &num1;     // Obtener la direccion de num1
	*pnum = 2L;		  // Asigna 2 a num1
	++num2;			  // Incrementa num2 
	num2 += *pnum;	  // adiciona num2 a num1

  	pnum = &num2;     // Obtiene la direccion de num2
	++*pnum;		  // Incrementa indirectamente num2
	
	printf("num1 = %d num2 = %d *pnum +num2 = %ld\n",num1,num2,*pnum,*pnum + num2);
	return 0;
  }
#+END_SRC

	RECIBIENDO ENTRADAS
   - Cuando recibe la entrada con *scanf()* usamos el operador & para obtener acceso a las
	 variables.
   - La variable para almacenar el segundo input(segundo argument)
   - Cuando un puntero contiene una direccion puedes usar el nombre del
	 puntero como argumento para scanf()
#+BEGIN_SRC C
  int value = 0;
  int *pvalue = &value;							//Marca el puntero para que refenrencie el valor

  printf("Input an integer: ");
  scanf("%d",pvalue);							//Lee el valor via puntero

  printf("Usted inserto el valor %d.\n",value); // Salida del valor entrado
#+END_SRC
	PROBANDO EL VALOR *NULL*
	- No se *DEBE* derefenrenciar un puntero inutilizado.
#+BEGIN_SRC C
	int *pt;	//Puntero inicializado
	*pt = 5;    //Un error terrible
  /*
   La segunda linea significa que almacena el valor 5 en una localizacion
   donde apunta el puntero. pt tiene un valor aleatoreo donde no se sabe
   donde el valor 5 sera almacenado.
  */
#+END_SRC
	- En el ejemplo anterior el puntero podria ser inofensivo,
	  o podria sobre escribir datos o codigos, o podria causar el
	  el crash del programa.
	- Crear un puntero solo crea la memoria para almacenar el puntero en si
	  - No gestiona la memoria para almacenar datos.
	  - Antes de usar un puntero, deberia asignarsele una posicion de memoria
		de una variable existente que a sido inicializada.
	  - Usar la funcion *malloc()* para gestionar la memoria primero.

	- El puntero se crea se debe inicializar en NULL
	  - *NULL* es un simbolo especial en C que representa el equivalente a 0 con
	    numeros ordinarios.
	  - *NULL* es equivalente a cero, si quieres probar cuaando el pvalue es *NULL*
	  - Puedes probar explicitamente que un puntero es *NULL* usando el operador ==.
#+BEGIN_SRC C
  #include <stdlib.h>
  //pvalue y pvalue2 son equivalente ya que asignar NULL o 0 es igual 
  int *pvalue  = NULL;
  int *pvalue2 = 0;

  if(!value)   // Chequea que pvalue es NULL

#+END_SRC
	- Se deb chequear que un valor es NULL antes de dereferenciar un puntero,
	  esto se hace a menudo cuando un puntero se pasa a funciones. 

*** DONE Punteros y constantes (Pointers and const) 
	CLOSED: [2023-10-31 mar. 09:22]
	- Cuando se usa el el modificador const en una variable o arreglo le dice al
	  compilador que el contenido de la variable/arreglo no cambiara en el programa.

    - Con los punteros hay que considerar dos cosas cuando se usan modificacdores de
	  const.
	  - Donde un puntero cambiara.
	  - Donde un valor al que el puntero apunta cambiara.
	- Las constantes en los punteros permiten modificar el comportamiento de estos cuando
	  va a cambiar su valor de direccion o el valor a donde apunta
	  Hay tres formas de modificar el puntero con *const* 

#+BEGIN_SRC C
  const int * value;       //No se puede modificar el valor al que apunta el puntero con el puntero.
  int *const value;		   //No se puede modificar la direccion a la que apunta el puntero.
  const int *const value;  //Es la union de los dos ejemplos anteriores.
#+END_SRC
	    

	

#+BEGIN_SRC C
int data = 1,data2 = 2,data3 = 3;

const int *ptr1 = &data //Esta declaracion no permite modificar el valor de data atravez del puntero.
*ptr1 = 50;             //Error

int *const ptr2 = &data2 //Esta declaracion no permite modificar el valor del puntero, osea la direccion a la que apunta no puede ser cambiada.  
ptr2 = &data             //Error

const int *const ptr3 = &data3 //Esta declaracion no permite modificar el valor del puntero, ni el valor de la variable a la que apunta.
ptr3 = &data             //Error
*ptr4 = 50;              //Error

#+END_SRC

- Otros ejemplos
#+BEGIN_SRC C
	int data = 10;
	const int *ptr = &data  //Esta declaracion no permite cambiar el valor de data atravez del puntero.
  *ptr = 20;              //Esto dara error
//------------------------------------------//
	int data2 = 2;
	int data3 = 3;
	int *const ptr2 = &data2; //Esta declaracion no permite cambiar la direccion del puntero 
	ptr2 = &data3;            //Error

//------------------------------------------//
	int data4 = 4;
	int data5 = 5; 
	const int *const ptr3 = &data4; //No se puede cambiar el valor de data4 atravez del puntero, ni cambiar la direccion al que el puntero apunta.
#+END_SRC

*** DONE Punteros void (Void pointers)
	CLOSED: [2023-10-31 mar. 09:33]

   - Los punteros *void* permiten guardar la direccion de memoria de cualquier tipo de elemento.
   - Se puede utilizar este puntero para retornar la direccion de memoria de un puntero
     dentro de una funcion sin retornar un valor en especifico
   - Si se almacena la direccion de una variable de un puntero de un tipo x a un puntero *void*
	 para obtener el puntero anterior hay que hacer un *typecast* del tipo de puntero deseado.
   - Cualquier tipo de puntero puede ser pasado como tipo (void ***)
	 - El puntero void no sabe el tipo de puntero esta apuntando asi que no se le puede
	   referenciar directamente,
	 - Se debe convertir al puntero deseado antes de derefenciar.
#+BEGIN_SRC C
#include <stdio.h>

void* retorna_valor_mas_1(int *valor){
  *valor += 1;
  return valor;
}

int main(int argc, char *argv[]){
  int data = 10; 

  printf("%d",*(int *)retorna_valor_mas_1( &data));
  
  return 0;
}
#+END_SRC

- Ejemplo 2

#+BEGIN_SRC C

    int i = 10; 
    float f = 2.34;
    char ch = 'k';

    void *vptr;
    vptr = &i;
    printf("Value of i = %d\n",*(int *)vptr);

    vptr = &f;
    printf("Value of f = %.2f\n",*(float *)vptr);

    vptr = &ch;
    printf("Value of f = %c\n",*(char *)vptr);

#+END_SRC

*** DONE Punteros y arreglos (Pointers and arrays)
	CLOSED: [2023-10-31 mar. 11:27]
    - Los punteros se usan principalmente en los arreglos para apuntar a direcciones de memoria.
	- Los arreglos son una coleccion de objetos del mismo tipo que usan el mismo nombre.
	- Los punteros y arreglos son bastantes difirentes, pero estan interrelacionados y
	  pueden ser intercambiables.

	- El uso mas comun de C son los punteros a arreglos.
	  Usarlo en arreglos es generalmente resulta en codigo que usa menos memoria.
	  EJEMPLO 1
#+BEGIN_SRC C
	//Apunta al primer elemento del arreglo
	int values[100];
	int *valuesPtr = &values[0];

	//Otra variante del caso anterior
	valuePtr = value;	
#+END_SRC
	- Si se tiene un arreglo de 100 enteros.
	- Se puede definir un puntero llamado valuesPtr que se use para acceder a los enteros contenidos
	  en este arreglo.
	- Cuando se define un puntero que es usado para apuntar a los elementos de un
	  arreglo,no se puede designar como tipo al que apunta el arreglo.
	  Se designa el puntero como el tipo al que de elemento que se esta apuntando que esta contenido
	  en el arreglo.
	EJEMPLO 2
#+BEGIN_SRC C
   int values[100];
   int value2 = 0; 
   int *valuePtr;
  valuePtr = values;  
	/*  Se inicializa el puntero al primer elemento del arreglo.
			Cuando se inicializa un puntero a un arreglo no se usado
			el & delante del valor del arreglo, como en otros tipos de
			variables.
	*/
	//Asignacion de la direccion de una variable comun, a un puntero
	valuePtr = &value2; 
	/*
		Una forma equivalente de generar un puntero al principio de un arreglo es aplicar
		el operador de direccion al primer elemento del arreglo.
	*/

	//Los ejemplos a continuacion son equivalentes
	valuesPtr = &values[0]; 
	valuesPtr = values; 


#+END_SRC

	RESUMEN
	- las expresiones AR[i] y **(AR + i) son equivalente en significado.
	  Ambos trabajan si *AR* es el nombre de un arreglo, y ambos son variables de un puntero.
	  Usar la expresion tal como *AR++* solo funciona si *AR* es una variable puntero.

*** DONE Aritmetica de punteros(Pointer arithmetic)
CLOSED: [2023-11-01 mié 06:16]
	- El verdadero poder de un puntero se muestra cuando se ve trabaja con una secuencia de elementos
	  en un arreglo.
    - La aritmetica de punteros te permite incrementar o decrementar la direccion de punteros sumando valores enteros al puntero.
	  Esta accion solo funciona bien con arreglos

#+BEGIN_SRC C
   int values[10] = {1,2,3,4,34,5,6,7,9,11};
   int *valuePtr = NULL;  //puede ser usado para ser acecedido al primer valor del arreglo values
   valuesPtr = values;     //valuePtr puede ser usado para acceder al arreglo en la primera posicion.
						  //o sea values[0]

   //Si se desea acceder al valor, del tercer elemento del arreglo (values[3]) con el puntero valuePtr
   //se puede aplicar el operador de indireccion como se muestra a continuacion.
  *(valuesPtr + 3)

  //La expresion de *(valuesPtr + i) puede ser usada para acceder al valor contenido en values[i]
  //para poner los valores de values[10] a 27, se puede hacer los siguiente:

  values = 27;
  //o usando valuesPtr

  *(valuesPtr + 10) = 27;

#+END_SRC

	- Se puede poner el valor de valuesPtr para apuntar al segundo elemento del
	  arreglo de valores. Puedes aplicar al operador de direccion a values[1]
	  y asignar el resultado a valuesPtr. 
	- Si valuesPtr apunta a values[0] puedes apuntar a values[1] simplemente adicionando 1
	  al valor de valuesPtr
	- La siguiente expresion es valida en C y puede ser usada por punteros de
	  cualquier tipo.
	
#+BEGIN_SRC C
  valuePtr += 1;
  ++valuesPtr;     // Pone el puntero en el proximo entero del arreglo values (values[1])
  --valuesPtr;     // Pone el puntero en el anterios entero del arreglo values
  				   // Asumiendo que el arreglo no estaba en el principio del arreglo
#+END_SRC

   - Los operadores de incremento (++) y decremento (--) tienen el mismo efecto que adicionar uno
	 o subtraer uno a un puntero.

#+BEGIN_SRC C Suma de elementos de un arreglo

  #include <stdio.h>
  #include <string.h>

			  //Ejemplo con la notacion de arreglo como parametro
	  int arraySum(int array[],const int n){
			  // Segun el tutorial aqui se recibe un puntero
			  // del primer elemento del arreglo
			  int sum = 0,*ptr;
			  int *const endArray = array + n;
			  for(ptr = array;ptr < endArray;++ptr)
				  sum += *ptr;

		  return sum;

	  }

	  //Ejemplo con la notacion de arreglo como puntero
	  int arraySumPointerNotacion(int *array,const int n){
			  int sum = 0;
			  // Como los punteros son notaciones hexadecimales
			  // al sumar (n) a la longitud del arreglo se cuenta
			  // la cantidad de bytes como parte de la longitud total
			  int *const endArray = array + n; 
			  for(;array < endArray;++array)
				  sum += *array;
			/* Tambien funciona con while

			 while( endArray > array) 
				sum += *array++;
			*/
		  return sum;

	  }

	  int main(void){
	  // int arraySum(int array[],const int); 
	  // int arraySumPointerNotacion(int *array,const int); 

	  // Los dos ejemplos de arriba son validos para pasar elementos de un
	  // arreglo como un puntero.

	  // Los prototipo anteriores sobran,
	  // ya que la funciones se pueden invocar sin este.
	  int values[10] = {3,7,-9,3,6,-1,7,9,1,-5};

	  printf("The sum is %i\n",arraySum(values,10));
	  printf("The sum is %i\n",arraySumPointerNotacion(values,10));
  }

#+END_SRC
   
#+BEGIN_SRC C
  // En (Punteros y arreglos (seccion anterior)) se muestra el uso de *valuesPtr y como este accede al primer elemento del arreglo con
  // con values[0]


  int array[] = "Hola me llamo Alejandro";
  int *ptr    = array;

  printf("%c",*ptr); //Aqui se motrara el carater 'H'  
  ptr++              //incremento en uno, tambien puedo escribirlo ptr = ptr + 1

  printf("%c",*ptr); //Aqui se motrara el carater 'o'  

  --ptr
  printf("%c",*ptr); //Aqui se motrara el carater 'H' nuevamente 
#+END_SRC

- Otro ejemplo de aritmetica de punteros
#+BEGIN_SRC C

	int arraySum(int array[],const int n){
			int sum = 0,*ptr;
			int *const arrayEnd = array + n;
			for(ptr = array;ptr < arrayEnd;ptr++ ){
					sum += *ptr;
			 }
			 return sum;
	}	

	void main(){
		int arraySum(int array[],const int n);
		int values[10] = {3,7,-9,3,6,-1,7,9,1,-5};
		printf("The sum is %i\n",arraySum(values,10));
	}
#+END_SRC	  
	RESUMEN

	- La aritmetica de punteros solo se puede aplicar
	  a punteros, no a arreglos.
	
	int urn[3];
	int **ptr1,* *ptr2;

	|------------------+---------------------|
	| Valido           | No valido           |
	|------------------+---------------------|
	| ptr++            | urn++               |
	|------------------+---------------------|
	| ptr2 = ptr1 + 2; | ptr2 = ptr2 + ptr1; |
	|------------------+---------------------|
	| ptr2 = urn + 1;  | ptr2 = urn * ptr1;  |
	|------------------+---------------------|

*** DONE Ejemplo de punteros y arreglos (Pointers and arrays example)
	CLOSED: [2023-11-02 jue. 13:51]
	- Es siguente ejemplo muestra el efecto de sumar un entero a un puntero.
#+BEGIN_SRC C EJEMPLO 1
	#include <stddef.h>
	#include <stdio.h>
	#include <string.h>
  	int main(void){
	 	char multiple[] = "a string";
	 	char *p = multiple;
	 	for (int i = 0; i < strnlen(multiple, sizeof(multiple));++i ){
		 	printf("multiple[%d] = %c ",i,multiple[i]);
		 	printf("*(p+%d) = %c ",i,*(p+i));
		 	printf( "&multiple[%d] = %p ",i,&multiple[i]);
		 	printf("p+%d = %p\n",i,p+i);
	 	}
	 	return 0;
	}
#+END_SRC
#+BEGIN_SRC C	
	#include <stdio.h>
  	int main(void){
	 	long multiple[] = {15L,25L,35L,45L};
	 	char *p = multiple;
	 	for (int i = 0; i < sizeof(multiple), sizeof(multiple[0]);++i ){
		 	printf("address p+%d (multiple[%d]): %llu *(p + %d) value: %d\n",i,i,(unsigned long long )(p + i),i,*(p + i));
		 	printf("\n Type long occupies: %d bytes \n",(int)sizeof(long));
	 	}
	 	return 0;
	}
#+END_SRC
*** DONE Punteros y cadena de caracteres (Pointers and strings)
	CLOSED: [2023-11-03 vie. 10:11]
	- Uno de las aplicaciones mas comunes del uso de un puntero a una arreglo es un puntero
	  a una cadena de caracteres.
	  - La razon de esta aplicacion es la notacion conveniente y su eficiencia.
	  - Usar una variable de tipo puntero char a una referencia de cadena de caracteres
		te da gran flexibilidad.
      -
#+BEGIN_SRC C Ejemplo de paso de (arreglo de parametros vs punteros char)

	void copyString(char to[],char from[]){
		 int i;
		 for (i = 0;from[i]!='\0';i++)
			 to[i] = from[i];
		  to[i] = '\0';
	}
	void copyString(char *to,char *from){
		 for (;*from != '\0';++from,++to)
			*to = *from;
		 *to = '\0';
	}


	//Ejemplo obtimizado de copiar el array
	void copyString(char *to,char *from){
		 while (*from)        /* El caracter null es igual a 0  */
			*to++ = *from++;  /* asi que saldra del ciclo cuando lo encuentre*/ 
		 *to = '\0';
	}

  int main (void) {
	char string1[]   = "A string to be copied.";
	char string2[50];

	copyString (string2,string1);
	printf("%s\n",string2);
  }


#+END_SRC
	
*** DONE Desafio contando cadeneas de caracteres (Challenge Counting characters in string)
	CLOSED: [2023-11-03 vie. 10:49]
	- Este desafio vas se probara el entendimiento de la aritmetica de punteros
	  y el modificador *const*.
	REQUISITOS
	- Escribir una funcion que calcule la longitud de una cadena
	  - La funcion debe tomar un parametro de tipo (const char pointer)
	  - la funcion solo puede determinar la longitud de una cadena
		usando aritmetica de punteros (usando ++pointer) para llegar al
		final de la cadena.
	  - Se requiere usar el ciclo *while* usando el valor del puntero para
		salir del ciclo.
	  - La funcion debe subtraer dos punteros, uno apuntando al principio
		y otro al final de la cadena.
	  - La funcion debe retornar una int de la longitud de la cadena que
		se le pasa.

#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>

  int array_lenght(const char *sentence){
	  const char *pos_init = sentence;
	  while(*sentence)
		  sentence++;
	  return sentence - pos_init;
  }

//Segunda variante
int array_lenght2(const char *sentence){
	const char *pos_fin = sentence;
	while(*pos_fin)
		pos_fin++;
	return pos_fin - sentence;
}


  int main()
  {
	  char sentence[] = "Ejercicio de la longitud de la cadena de caracteres";
	  printf("La longitud del arreglo es : %d\n",array_lenght(sentence));
	  return 0;

  }

#+END_SRC
	
*** DONE Pasando por referencia (Pass by reference)
	CLOSED: [2023-11-03 vie. 13:07]
	Hay dos formas de pasar informacion por una funcion
	- Por valor.
	- Por referencia.

    - Las llamadas por valor son aquellas que reciben el dato en la funcion pero
	  hacen una copia de este para luego devolver el o los valorer deseaos por la funcion.
    - La llamadas por referencia se les pasa la direccion de una variable el cual
	  permite modificar el valor original sin crear una copia de la variable original.
    - Los parametros de las funciones de llamada por referencia, se declaran con * y
	  cuando se los pasa un parametro que no es un array se usa el simbolo & que
	  significa direccion de el valor.
	- En caso de los arreglos no se usa el simbolo & para hacer llamada por referencia.
#+BEGIN_SRC C
  #include <stdio.h>

  int func_by_value(int val){
	return val + 1;
  }

  void func_by_reference(int *val){
	 *val += 1;
  }

  int main(){
	int value = 10;

	printf("La function por valor retorna %d .\n",func_by_value(value));

	printf("El valor de value es %d .\n",value);

	func_by_reference(&value);

	printf("El valor de value despues de la funcion por referencia es: %d.",value);

	return 0;

  }
#+END_SRC

#+BEGIN_SRC C llamada por valor
	#include <stdio.h>
	 void swap(int x, int y){
		int temp;

		temp = x;
		x = y;
		y = temp;

		return;
	 }


   int main(){

	//Definicion de variables locales
	int a = 100;
	int b = 200;

	printf("Before swap, value of a: %d",a);
	printf("Before swap, value of b: %d",b);
	/* calling a function to swap the values */

	swap(a,b);


	printf("After swap, value of a: %d",a);
	printf("After swap, value of b: %d",b);

	return 0;
  }

#+END_SRC

	PASANDO DATA USANDO COPIAS DE PUNTEROS
	- Se puede pasar punteros como argumento a funciones y tambien una funcion
	  puede retornar un puntero como resultado.
	- En llamada por referencia se copia la direcion de un argumento en un
	  parametro formal.
	  - La direccion es usada para acceder el argumento actual usado en la
		llamada.
	  - Cuando se realiza un cambio el parametro este afecta al argumento. 
    - En las llamadas por referencias se pasa un puntero a las funciones como
	  cualquier otro valor.
	  - Se necesita declarar los parametros como punteros.
	  - Los cambios dentro de la funcion se refleja fuera tambien.
	  - Al contrario de llamadas por valor que no afecta fuera de la funcion.

#+BEGIN_SRC C llamada por referencia
	#include <stdio.h>
	 void swap(int *x, int *y){
		int temp;

		temp = *x;   // Guarda en temp el valor de la direccion x
		,*x = *y;     // Guarda en y el valor de x
		,*y = temp;	 // Guarda en y el valor de temp

		return;
	 }


   int main(){
	//Definicion de variables locales
	int a = 100;
	int b = 200;

	printf("Before swap, value of a: %d",a);
	printf("Before swap, value of b: %d",b);
	/* calling a function to swap the values */

	swap(&a,&b);

	printf("After swap, value of a: %d",a);
	printf("After swap, value of b: %d",b);

	return 0;
  }

#+END_SRC

	PUNTEROS *CONST* COMO PARAMETROS
	- Se puede calificar los parametros de una funcion usando *const* 
	  - Esto indica que la funcion tratara sus parametros como constantes
	  - Solo es util cuando el parametro es un puntero.


	MUY IMPORTANTE 
	- Se puede aplicar la palabra const a un parametro que es un puntero para
	  especificar a la funcion que no cambie el valor al que apunta el puntero

#+BEGIN_SRC C
  bool send_message(const char* pmessage){
		return true;
  }
#+END_SRC
  - EL tipo de parametro, pmessage es un puntero a const char
	- Es valor del char es el que es constante no la direccion.
	- Se puede especificar que el puntero en si sea constante tambien. Este caso
	  tiene menos sentido porque se pasa a la funcion el parametro por referencia
	  y se desea manipular la direccion del parametro.
  - Se puede retornar punteros de funciones siendo estos con una funcionalidad poderosa
	la cual provee una forma para retornar no 1, sino multiples parametros.
  - Se debe tener cuidado con lo anterior mencionado. Se deben usar variables locales
	para evitar interferir con las variables a la que apunta el puntero.
*** DONE Usando punteros como parametros (Using Pointers as parameters)
	CLOSED: [2023-11-03 vie. 13:18]
	- Este desafio se realiza para probar el entendimiento de parametros
	  pasados por refenrencia.
	- Escribe una funcion que eleve al cuadrado el numero en si.
	  - La funcion define como parametro un puntero int.

#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>

  void double_ptr(int *elm){
	  //*elm = *elm * *elm;   // Se puede usar esta variante pero para evitar confuncion es mejor usar 
							  // la siguiente.
	*elm = (*elm) * (*elm);  
  }

  int main()
  {

	  int elm = 4;
	  //int elm2 = (int *) malloc(sizeof(int));
	  //double_ptr(elm2);
	  // Es otro ejemplo de como crear una variable con malloc

	  double_ptr(&elm);
	  printf("Elm es : %d\n",elm);

	  free(elm2);

	  return 0;

  }
#+END_SRC

*** DONE Reserva dinamica de memoria (Dynamic memory allocation)
CLOSED: [2023-11-04 sáb 20:46]
	- Cuando se crea una variable en C el compilador automaticamente ubica la
	  cantidad correcta de memoria de almacenamiento basado en su tipo de datos.
	- Existe a veces la necesidad de guardar dinamicamente memoria adicional
	  mientras el programa esta corriendo.
	- Si se tiene un programa que lee dedes un archivo entonces tienes 3 opciones:
	  - Definir un arregloe que contiene un numero de elementos posibles en tiempo
		de compilacion.
	  - Usa un arreglo de longitud variable para dimensionar la longitud del arreglo
		en tiempo de ejecucion.
	  - Crear un arreglo dinamico usando una de las rutinas de C para selecion dinamica
		de memoria.
	SELECION DINAMICA DE MEMORIA (Dynamic memory allocation)
    - Con el primer acercamiento se define el arreglo que contiene el numero maximo
	  de elementos que se deveran leer dentro del arreglo.
	  #+BEGIN_SRC C
		int dataArray [1000];
	  #+END_SRC
	- dataArray no puede contener mas de 1000 elementos, si lo hace el programa
	  no funcionara.
	   - Si los datos son mas de 1000 se debe volver al programa y cambiar el tamanio
		 para hacerlo mas largo.
	   - No importa que valor seleccion, simpre tendras el mismo problema en el futuro.
	   - Usuando funciones de selecion dinamica de memoria, se puede almacenar tanto se
		 necesite, este acercamiento permite guardar la memoria mientras
		 el programa se ejecuta. 
	- La selecion dinamica de memoria depende del concepto del puntero
	  e incentiva el fuerte uso del mismo en el codigo.
	- La selecion dinamica permite almacenar informacion en la memoria cuando se ejecuta
	  el porgrama.
	  - Este comportamiento solo es posible si debido a los punteros disponibles.
	- La mayoria de los juegos en produccion usan seleccion de memoria dinamica
	- Esta funcionalidad permite crear punteros en tiempo de ejecucion que
	  son los suficientemente grandes para aguantar los datos requeridos
	  para la tarea.
	 HEAP vs STACK (Cumulo vs Pila)
	
	 - La selecion dinamica de memoria reserva espacio en un espacio de memoria
	   llamada el cumulo(HEAP)
	 - La pila(STACK) es otro lugar donde la memoria es guardada
	   - los argumentos de una funcion y variables locales son almacenadas aqui.
	   - Cuando la funcion se termina de ejecutar el espacio reservado los
		 elementos almacenados y variables locales es liberados.

     - La memoria en el cumulo es diferente y es controlado por el programador
	   - Cuando se almacena la memoria en el cumulo, depende de el programador
		 seguir el rastro de la memoria que ya no se usa.
	   - El programador debe liberar la memoria  que no se usa para ser reutilizada.
*** DONE Malloc, calloc, realloc
CLOSED: [2023-11-05 dom 01:25]
	- La memoria creada dinamicamente permite asignar memoria adicional en tiempo de ejecucion.
	- Existen tres formas bases de reservar memoria dinamicamente estas se encuentran
	  en la biblioteca *stdlib.h*
		1. malloc 
		2. calloc
		3. realloc
	- Para liberar la memoria reservada se usa la funcion *free* de la misma biblioteca.
	- La funcion *malloc* reserva memoria basada en el numero que se le pasa por parametro.
	  Este valor representa la cantidad de bytes a reservar en memoria. La funcion retorna
	  un puntero *void* que hay que dereferenciar al tipo de memoria que se desea reservar.  
	- Es importante verificar si la memoria fue reservada correctamente por *malloc*
	  para poder lidiar con los errores de este.
	- No se debe reservar memoria dentro de un ciclo *while* o *for* aunque se lleve la lista
	  de espacios de memoria reservada.

	- Las tres funciones retornan un parametro de tipo (void *) que devuelve la
	  direccion de memoria que se reservo o NULL si la operacion falla por
	  alguna razon.
	
	MALLOC
	- Es la funcion mas simple de la biblioteca *stdlib.h*
	  - se necesita incluir *stdlib.h* como archivo de cabecera
	  - Se especifica el numero de bytes a reservar como argumento
	  - Retorna un puntero de tipo void de la primera posicion de memoria que
		se esta apuntando.
		
	  - En el siguiente codigo se reserva 100 bytes de memoria a asignar la
		direccion del bloque de memoria a test.
		- test apuntaara al imer bloque de memoria al principio de los 100 bytes
		  que fueron seleccionados.
		- Como ejemplo puedes almacenar hasta 25 valores de 4 bytes cada uno.
		- Asumiendo que un entero tiene 4 bytes.
		- Seria mejor eliminar la duda de si el entero es de 4 bytes

     LIBERAR LA MEMORIA
	 - Cuando se reserva la memoria dinamicamente, se debe liberar la memoria
	   cuando ya no se necesita.
	 - La memoria que se almacena en el heap sera automaticamente liberada cuando
	   el programa termina.
	   - Se recomienda liberar la memoria explicitamente con se termine de usar
		 incluso antes de terminar el programa.
	 - La filtracion de memoria ocurre cuando almacenas memoria dinamicamente
	   y no se retiene la referencia de esta siendo imposible liberar el espacio
	   de memoria ocupado.
	   - La anterior ocurre en un ciclo.
	   - Debido a que no se libera la memoria cuando ya no es requerida el programa
		 consume mas de la memoria requerida en cada iteracion y eventualmente puede
		 ocupar toda.
	   - Para liberar la memoria ocupada dinamicamente, se debe acceder a la direccion
		 que bloquea la memoria.
	   - La funcion *free()* tiene un parametro formal de tipo void, el cual permite pasar
		 un parametro de cualquier tipo como parametro.
	   - Despues de liberar la memoria se debe por precaucion poner el puntero a *NULL* en
		 donde se ha liberado la memoria.
		 
#+BEGIN_SRC C

	 #include <stdlib.h>

	int main(){
		int *test = (int *)malloc(100); // Funciona pero no es recomendado ya que puede crear problemas.
		//En multiples sistemas operativos un int puede valer 4 bytes o 2 bytes.

		int *test = (int *)malloc(25 * sizeof(int)); // Funciona mejor
		//Se reserva 25 elemento de tipo int
	if(!test) {  //Verifica si se reservo la memoria y si no es NULL
							 //Aqui va el codigo que trata el NULL de la reservacion de la memoria.
	}
	free(test);    //Aqui se libera la memoria ocupada por malloc
	*test = NULL;  //Para dejar la memoria liberada. 
	}
#+END_SRC
  CALLOC
- La funcion *calloc* reserva memoria basada en el numero que se le pasa por
  parametro y el tamanio de los valores a reservar. Aunque esta funcion es
  similar a *malloc*, *calloc* inicializa los valores cuando reserva la memoria .
- Esta funcion tiene dos ventajas sobre malloc:
  - Inicializa parametros de un tamanio determinado.
  - Toda la memoria es inicializada 
- Nesecita dos parametros:
  - Numero de elementos dado un tamanio dado.
  - El tamanio del tipo de parametros que se va a inicializar.
#+BEGIN_SRC C
	 #include <stdlib.h>

	int main(){
		char array[50] = "Hola mundo como estas hoy.";
		char *test = (char *)calloc(20, sizeof(char)); 

	if(!test){
		//aqui valido que no es NULL el valor de memoria que reserve con calloc
	}

	free(test);   
	*test = NULL; 
	}
#+END_SRC
  REALLOC 
- La funcion *realloc* reserva memoria basada en la memoria ya reservada anteriormente
  mas la memoria adicional que se desea reservar.
- La funcion espera dos argumentos:
  - Un puntero que contiene la direccion de memoria que retorno la llamada de
	calloc() y malloc()
  - EL tamanio en bytes que se desea reserva en memoria nuevamente, para aumentar
	y disminuir la memoria deseada.
- La caracteristica mas importante de esta operacion es que preserva los datos
  de los elementos del area de memoria.
#+BEGIN_SRC C Ejemplo 1

   #include <stdlib.h>

  int main(){
	  char array[50] = "Hola mundo como estas hoy.";
	  char *test  = (char *)calloc(10, sizeof(int)); 
	  //No se reservo memoria nesesaria para la cadena.
	  test = (char *)realloc(test,20); 

  if(!test){
	  //aqui valido que no es NULL el valor de memoria que reserve con calloc
  }

  free(test);   
  *test = NULL; 

  }
#+END_SRC

#+BEGIN_SRC C Ejemplo 2
#include <stdio.h>
#include <stdlib.h>

void get_ptr_add(int **var){

	//Como liberar la memoria del puntero
  printf("la direccion del puntero es: %p\n", var);
  free(*var);
  *var = NULL;
}

int main(){
  int *ptr = (int *)calloc(70, sizeof(int)); 
  printf("la direccion del puntero es: %p\n", &ptr);
  get_ptr_add(&ptr);
  free(ptr);  //Ya se libero la memoria pero mientras que la memoria liberida apunte a NULL este free no dara problemas.
  
   return 0;
}
#+END_SRC

- Ejemplo de como pasar punteros de punteros por una funcion.

#+BEGIN_SRC C Ejemplo 3
#include <stdio.h>
#include <stdlib.h>

void get_ptr_add(int **var){

    printf("%p la direccion del puntero \n", var);
    printf("%p es la direccion a la que apunta el puntero\n", *var);
    printf("%d es el valor de la variable \n", **var);
}


int main(){
  int a = 10; 
  int *ptr = &a;
  printf("%p es la direccion del puntero \n", &ptr);
  printf("%p es la direccion a la que apunta el puntero \n", ptr);
  printf("%p es la direccion de la variable a \n", &a);
  printf("%d es el valor de la variable \n", a);
  printf("%d es el valor de la variable atravez del puntero \n\n", *ptr);
  get_ptr_add(&ptr);
  
   return 0;
}
#+END_SRC

#+BEGIN_SRC C Ejemplo del tutorial
  int main(){
	  char * str;
		/* Initial memory allocation */
		str = (char *) malloc(15);
		strcpy(str,"jason");
		printf("String = %s,Address = %u\n",str,str);

		free(str);

  		return 0;
	}
#+END_SRC
	GUIAS 
	- Evita resrevar muchos pequenios grupos de memoria
	  - Reservar espacios de memoria en el HEAP conlleva sobrecarga.
	  - Es mejor reservar pequenios grupos de grandes bloques de memoria,
		que grandes grupos de pequenios bloques de memoria.
	- Usa la memoria mientras la necesecites.
	  - cuando termines de usar la memoria reservada, liberala.
	- Siempre asegurarse de poveer una liberacion de memoria cuando la selecciones
	- Decide cuando en tu codigo se liberara la memoria que decides reservar. 
	- Asegurarse de no asignar memoria que ya ha sido asignada en el HEAP antes
	  de liberar el espacio.
	  - Esto provocara problemas de filtracion de memoria(memory leak)
	  - Se debe de ser cuidadoso cuando se reserva memoria en un ciclo.
		
*** DONE Desafio de memoria dinamica (Challenge Dynamic memory)
CLOSED: [2023-11-06 lun 12:04]
	- Escribe un programa que le permita al usuario insertar una cadena de texto
	  EL programa de texto que sera mostrado es el que se insertara.
	- Este programa usa la reserva dinamica de memoria.
	- EL usara el limite de la cadena de carateres limitando los caracteres
	  que se entran poniendo el limite con la funcion malloc.
	  - EL programa solo usara un puntero de tipo char, no se permiten cadenas de caracteres.
	  - se debe liberar la memoria selecionada.

#+BEGIN_SRC C mi version

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>


  void print_str(char *const str){
	  char * fin = str;
	  printf("La cadena es: ");
	  while(*fin != '\0'){
		  printf("%c",*fin);
		  fin++;
	  }	
	  printf(" La longitud de la cadena es de: %lld caracteres \n",fin - str);
    }


  int main(void) {
	  int lon;
	  char *oracion;

	  printf("Diga la cantidad de letras: ");
	  scanf("%d",&lon);

	  oracion = malloc(sizeof(char) * (lon + 1));

	  if(!oracion){
		  printf("Error al inicializar el espacion de memoria deseado.");
		  exit(1);
	  }

	  printf("Inserte un texto con %d caracteres \n",lon);

	  //No logro que fgets funcione sin scanf
	  scanf(" ");
	  fgets(oracion,lon + 1,stdin);

	  print_str(oracion);

	  free(oracion);
	  oracion = NULL;
  
	  return 0;

  }
#+END_SRC


- EL SIGUENTE EJEMPO ES MUY IMPORTANTE PARA LA CAPTURA DE DATOS POR CONSOLA.
#+BEGIN_SRC C version modificada de captura dinamica de datos(C notes for profesionals pag 323)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
	int num,c;
    char *str, *lf;

	printf("Selecione el tamanio de la variable: ");
    scanf("%d", &num);
	str = (char *) malloc(sizeof(char) * num +1);

	printf("Escriba el texto con no mas de %d caracteres : \n",num);
	while ((c = getchar()) != '\n' && c != EOF);
	fgets(str, num + 1, stdin);

	if ((lf = strchr(str, '\n')) != NULL) *lf = '\0';
		printf("%d \"%s\"\n", num, str);

	free(str);
	str = NULL;

		
   return 0;
}
#+END_SRC

#+BEGIN_SRC C Ejemplo del tutorial

#include <stdio.h>
#include <stdlib.h>

int main()
{
   int size;
   char *text = NULL;

   printf("Enter limit of the text: \n");
   scanf("%d", &size);

   text = (char *) malloc(size * sizeof(char));

   if (text != NULL)
   {
       printf("Enter some text: \n");
       scanf(" ");
       gets(text);

       printf("Inputted text is: %s\n", text);
   }

   free(text);
   text = NULL;
   return 0;
}


  
#+END_SRC
	
*** DONE Ejemplo Extra (Liberar cualquier tipo de puntero creado dinamicamente)
	CLOSED: [2023-11-15 mié. 14:23]
	
	- El siguente ejemplo esta probado con punteros a char pero sirve para
	  cualquier tipo de puntero.
#+BEGIN_SRC C

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  void free_memory(void **elm){
	  if(*elm != NULL){
		  free(*elm);
		  *elm = NULL;
	   }
  }


  int main()
  {
	  char *nombre = malloc(sizeof(char) * 20);

	  strncpy(nombre,"Alejandro",20);

	  printf("El valor de nombre antes de liberarlo es: %s \n",nombre);
	  printf("La direccion de nombre antes de liberarlo es: %p \n",nombre);
	  //Pasa la direccion de memoria de la variable y la convierte a double puntero void
	  free_memory((void**)&nombre);
	  printf("El valor de nombre despues de liberarlo es: %s \n",nombre);
	  printf("La direccion de nombre despues de liberarlo es: %s \n",nombre);

	  return 0;
  }

#+END_SRC

** DONE Structures [7/7]
CLOSED: [2023-11-26 dom 11:12]
*** DONE Creando y usando estructuras(Creating and using structures)
	CLOSED: [2023-11-10 vie. 08:08]
	- Las estructuras en C proveen de otra herramienta para agrupar elementos juntos
	  - Es un concepto poderoso que se usara en muchos programas que se desarrolle.
	- Suponga que se almacena una fecha dentro del programa.
	  - Se puede crear variables para mes, dia y año par almacenar fecha.
	- Suponga que su programa tambien nesecita almacenar la fecha de un objeto
	  en particular.
	  - Se debe seguir el rastro de las 3 variables separadamente por cada fecha que
		se use en su programa.
	  - Estas variables son logicamente relacionadas y deberian estar agrupadas juntas.		 
   - La palabra estructura habilita definir una coleccion de variables de varios tipos
	 llamada estructura que se puede tratar como una unidad.
#+BEGIN_SRC C
  struct date //declaracion de la estructura
	{
		int year;
		int month;
		int day;
	}

  	struct date today;  //declaracion de una instancia de una estructura

	today.year = 2023;
	today.month = 5;
	today.day = 1;

#+END_SRC

	- La declaracion anterior esta definida como una estructura de fecha en C.
	- No hay reserva de memoria en esta declaracion
    - Se puede inicializar una instancia de la struct ya declarada con typedef

#+BEGIN_SRC C struct declarada con typedef
  typedef struct {
		int year;
		int month;
		int day;
	} Date;

	 Date today = { 2023, 5, 26};

#+END_SRC

	- Una vez declarada la estructura la memoria se reserva para el contenido.
	- En el ejemplo anterior se reserva espacio para tres entero que estan dentro de la
	  estructura. 

    ACCEDER A LOS MIEMBROS DE UNA ESTRUCTURA
	- Se puede acceder a un miembro de la estructura escribiendo el nombre de la variable
	   seguido por el operador punto ( . ) y luego la variable a la que se quiere acceder.
	- El punto entre el nombre de una estructura y el nombre de la variable se le llama
	  operador de seleccion.
	- No se escribe con espacios entre la estructuras y los miembros de la estructura.

#+BEGIN_SRC C 
	  struct Date today;

	  today.year = 2023;
	  today.month = 5;
	  today.day = 1;
	  if(today.month == 12) 
		nextMonth = 1;
      
#+END_SRC

	ESTRUCTURAS COMO EXPRESIONES
	- Cuando se trata de una estructura como una expresion, los miembros siguen
	  las mismas reglas como variables ordinarias.
	- Como ejemplo de una division un miembro de una estructura por otro entero
	  se realiza como una division de enteros.

#+BEGIN_SRC C
	century = today.year / 100 + 1;
#+END_SRC


	DEFINIR ESTRUCTURAS Y VARIABLES AL MISMO TIEMPO
	- Es valido declarar una variable de un tipo de estructura en particular
	  al mismo tiempo que la estructura es definida.
	- Se incluyen el nombre de variables antes de poner el punto y coma
	  en la definicion de la estructura.
	- Se puede asignar valores iniciales a las variables de forma normal.

    - Se puede inicializar una variable cuando se declara la estructura
    - En este caso se declaro e inicializo la variable today de tipo struct date

#+BEGIN_SRC C
	struct date {   
		int year;
		int month;
		int day;
	} today; 

	today.year = 2023;
#+END_SRC

	ESTRUCTURAS SIN NOMBRES
    - Se puede inicializar una struct de un solo uso, esta se les conoce como estructuras anónimas.
	- Las desventajas de la siguiente declaración es que no se puede crear instancia
	  de una estructura en otra declaracion.
	- Todas las variables de este tipo estructura que se quiere en el programa
	  deben definirse en una declaracion.
#+BEGIN_SRC C

  struct {     // Declaracion de una estructura
	  int year;
	  int month;
	  int day;
  } today;     // Declaracion de estructura combinado

#+END_SRC

	INICIALIZANDO UNA ESTRUCTURA
    - Se puede inicializar las variables de las estructuras como si fueran elementos
      de un arreglo, manteniendo la lógica de declaracion de las variables en la estructura.
	- Los valores iniciales listados dentro las llaves curvas deben ser expresiones constantes.
    - Se puede inicializar parcialmente la estructura.
	- En el siguiente ejemplo en la tercera declaracion se muestra como se le asigna
	  valor a mes y dia pero no año.
#+BEGIN_SRC C
	  //                 year month day
  struct Date today = { 2023 ,  5 ,   1};

	 //                  year month // Inicializacion parcial 
  struct Date today = { 2023 ,  5}; // Se inicializa 

	// Inicializacion de miembros especificos de la estructura
  struct Date today = { .year = 2023 , .month = 5};

#+END_SRC
	ASIGNACION CON COMPUESTOS LITERALES
    - Se puede inicializar la estructura con elementos de la misma con
	  literales compuestos.
    - Los valores al asignarlos deben tener el mismo orden de declaracion dentro
	  de la structura, igual a su asignacion.
	  - Esto no es una declaracion.
	  - El operador de *typecast* es usado para decirle al compilador el tipo de expresion.
	  - La lista de valores que sigue la invocacion son asignados a miembros
		de la estructuras, en orden.
	  - Los mimbros son listados en la misma forma que fue creada la estructura.
#+BEGIN_SRC C

  today = (struct date) = { 2023 , 5, 30 };

#+END_SRC

	-  Se puede combinar la asignación con miembros en los literales compuestos. 
	-  La ventaja de esta aproximación es que los argumentos pueden aparecer en cualquier orden.
	
#+BEGIN_SRC C Inicializacion de literales compuestos
	  struct date {   
		  int year;
		  int month;
		  int day;
	  };

  struct date today;
  today.year = 2023;
  today.month = 5;
  today.day = 1;

  today = (struct date) = { 
		  .month = 9 , 
		  .day = 24 ,
		.year = 2023 
	};

#+END_SRC

*** DONE Estructuras y arreglos(Structures and arrays)
	CLOSED: [2023-11-10 vie. 09:23]

   - C permite la creacion de estructuras de arreglos y arreglos de estructuras. 
   - Declarar un arreglo de estructuras es como declarar cualquier otro tipo de arreglo.

#+BEGIN_SRC C
	  struct date {   //Declaracion de la estructura
		  int day;
		  int month;
		  int year;
	  };
     // Cada elemento dentro del arreglo es como declarar varios elementos de estructuras
     struct date mydates[10];

#+END_SRC

    - Para acceder a cualquier miembro de una estructura se usa los corchetes para
	  seleccionar los elementos del arreglo y luego se usa el operador ( *.* ) para acceder
	  a los valores de dicha estrutura.

#+BEGIN_SRC C

	mydates[0].month = 12;
	mydates[0].year  = 2023;
	mydates[0].day   = 9;

#+END_SRC

   - Otra forma de inicializar el arreglo es haciendolo como un arreglo multidimencional. 
   - La siguiente inicialización solo inicializara los primeros 3 elementos del
  	 arreglo.
   - Tambien se puede inicializar sin las llaves internas pero esta opcion
	 tiende a provocar confusion.

#+BEGIN_SRC C

  struct date myDates[10] = {   
		   {1,3,2030},
		   {15,10,2012},
		   {15,12,2002},
   };

  //Inicializacion sin llaves internas
  struct date myDates[10] = { 1,3,2030,15,10,2012,15,12,2002 };

#+END_SRC

    - Se puede inicialisar elementos especificos del arreglo seleccionando la posición.
    - De la inicializacion del arreglo por posicion se puede inicializar los
	  parametros especificos deseados.

#+BEGIN_SRC C

  //Se inicialición solo la tercera posicion del arreglo.
  struct date myDates[10] = { [2] = { 1,3,2030 } };

  //Inicializacion de parametros en una posicion dada.
  struct date myDates[10] = { [2].day = 1,[2].month = 3 };

#+END_SRC 

	ESTRUCTURAS CONTENIENDO ARREGLOS
	- Es posible definir estructuras que contengan arreglos como miembros
	  - Es comun usar un arreglo de caracteres dentro de una estructura.

#+BEGIN_SRC C

  struct month {   //Declaracion de la estructura
	     int numberOfDays;
	     char name[3];
  };

   struct month mymonth;
	  mymonth.numberOfDays = 31;
	  mymonth.name[0] = 'J';
	  mymonth.name[1] = 'a';
	  mymonth.name[2] = 'n';

  //Otra forma de inicializar una estructura con arreglos dentro
   struct month mymonth = { 31,{'J','a','n'} };

#+END_SRC

*** DONE Estructras anidadas (Nested structures)
	CLOSED: [2023-11-10 vie. 09:43]

    - C permite definir estructuras dentro de estructuras
	- Como se puede ver en capitulos anteriores

#+BEGIN_SRC C
    struct date {
        int day;
        int month;
        int year;
        char list_of_months[12],
    };

    struct time {
        int hours;
        int minutes;
        int seconds;
    };

    struct DateAndTime {
        struct date sdate;
        struct time stime;
    };

#+END_SRC


    - EL primer miembro de DateAndTime la estructura is de type struct date
	  y el segundo de tipo struct time.
    - Habiendo definido las estructuras dentro de la nueva estructura de
	  tipo DateAndTime se puede crear una de este tipo, creando estructuras anidadas.
    - Para acceder a los miembros de las estructuras anidadas se usa el operador punto ( *.* )

#+BEGIN_SRC C

  struct DateAndTime {
	struct date sdate;
	struct time stime;
  }

  struct DateAndTime event;

  //Accediendo a la estructura dentro de event;
  event.sdate

  //Accediendo a los valores de la estructura sdate dentro de event;
  event.sdate.month = 10;

  //Realizando operaciones con los datos anidados de la estructura sdate dentro de event;
  event.sdate.month = 10;

  //Incrementa en uno el valor de month 
  ++event.sdate.month;
  event.sdate.month++;

#+END_SRC

   - La inicializacion de estructuras dentro de estructura se realiza como un arreglo

#+BEGIN_SRC C

  struct DateAndTime event = {{2,1,2015},{3,30,0}};

#+END_SRC

   - Se puede inicializar por miembros siguendo el orden de declaracion de los elementos de la estructura

#+BEGIN_SRC C
    struct DateAndTime event = {
          {.month = 2,.day = 1, .year = 2015},
          {.hour = 3, .minutes = 30, .seconds = 0}
        };
#+END_SRC

   - Se puede inicializar de una lista de elementos anidados con un arreglos de los mismos

#+BEGIN_SRC C
    struct DateAndTime events[100];
    events[0].stime.hour        = 12;
    events[0].stime.minutes     = 0;
    events[0].stime.seconds     = 0;
#+END_SRC

  DECLARAR ESTRUCTURAS DENTRO DE ESTRUCTURAS
  - Puede declarar una estructura dentro de otra estructura, donde el valor
	de la interior no se puede declarar fuera de esta.

#+BEGIN_SRC C 
    struct time {
    struct date {
        int day;
        int month;
        int year;
    } dob;
        int hours;
        int minutes;
        int seconds;
    };

#+END_SRC

*** DONE Estructuras y punteros (Structures and pointers)
	CLOSED: [2023-11-10 vie. 10:12]
    - Las estructuras se pueden inicializar con punteros y funcionar como otros
	  tipos de puntero.
    - Los punteros son mas sencillas de manipular que las estructuras en si.  
	- En algunas implementaciones las estructura no se podian pasar por funciones
	  por los que se usan punteros de estas.
#+BEGIN_SRC C
    struct date {
        int day;
        int month;
        int year;
    };

struct date today,*datePtr;
datePtr = &today;

#+END_SRC

   - Se puede acceder indirectamente a cualquier elemento de la estructura de today
	 atravez del puntero Stcptr
   - En el siguiente el parentesis es necesario porque el operador ( . ) tiene mayor
	 precedencia que el operador de indireccion ( * )
#+BEGIN_SRC C
  //Se usa los parentesis porque el operador . tiene mayor precedencia que el operador *
  (*datePtr).day = 10;

  //La forma mas conocida es con el operador ->
  datePtr->day = 10;

  //Se puede conciderar que (*x).y es igual a x -> y

  // Es una sintaxis valida
  if((*datePtr).month == 12) 


#+END_SRC

- Ejemplo completo 
#+BEGIN_SRC C
    struct date {
        int day;
        int month;
        int year;
    };

	struct date today,*datePtr;
	datePtr = &today;


	datePtr->day   = 9;
	datePtr->month = 10;
	datePtr->year  = 1785;

	printf("Hoy es %i del %i de %.2i\n",datePtr->day,datePtr->month,datePtr->year % 100);

#+END_SRC

   - Las estructuras pueden contener punteros.
   - Se puede acceder a los elementos de esta como elementos de una estructura corriente.

#+BEGIN_SRC C
    struct intPtrs {
        int *p1;
        int *p2;
    };

	struct intPtrs pointers;
	int i1 = 100, i2;

	pointers.p1  = &i1;
	pointers.p2  = &i2;
	*pointers.p2 = -97;


	printf("i1 = %i, *pointers.p1 = %i\n",i1,*pointers.p1);
	printf("i2 = %i, *pointers.p2 = %i\n",i2,*pointers.p2);

#+END_SRC

   - La inicializacion de arreglos de caracteres en las estructuras y punteros
	 en la estructura son bastante similares, pero tiene diferencias notables.   
   - En el siguente caso la estructura names tiene reservada la 40 bytes en
	 elementos char.
   - En el caso de la estructura pnames tiene reservada la 2 byte en elementos
	 char*, permitiendo cambiar el tamanio a dinamicamente.
   - Los punteros que se crean dentro de una estructura almacenan valores
	 constantes con lo que se inicializan o se reserva espacio con malloc, calloc ect...

#+BEGIN_SRC C
    struct names {
        char first[20];
        char last[20];
    };

    struct pnames {
        char *first;
        char *last;
    };

    struct names  veep  = {"Talia","Summers" };
    struct pnames treas = {"Brad","Fallingjaw"};
    printf("%s and %s\n",veep.first,veep.last);
#+END_SRC

   - Ejemplos de punteros utilizando memoria dinamica
   - Es importante enterder que no hay dos cadenas de caracteres almacenada en la
	 estructura.
   - La direccion para dos cadenas esta almacenada en la estructura.
   - Las direccion se usan normalmente en funciones de manejo de cadenas.
	 
#+BEGIN_SRC C Ejemplo 1

  struct namect {

	char *fname; //usando punteros en vez de arreglos
	char *lname;
	int letters;

  }

#+END_SRC

   
#+BEGIN_SRC C Ejemplo 2

  void get_info(struct namect* ptr){

	  char temp[SLEN];
	  printf("Por favor introdusca su primer nombre.\n");
	  s_gets(temp,SLEN);

	  //Reserva memororia que guarde el nombre
	  ptr->fname = (char *)malloc(strlen(temp) + 1);   
	  strcpy(ptr->fname,temp);

	  printf("Por favor introdusca su primer apellido.\n");
	  s_gets(temp,SLEN);

	  //Reserva memoria que guarde el segundo nombre
	  ptr->lname = (char *)malloc(strlen(temp) + 1);   
	  strncpy(ptr->lname,temp,SLEN);

  }
#+END_SRC

*** DONE Estructuras y funciones (Structures and functions)
	CLOSED: [2023-11-10 vie. 14:33]
	- En las funciones se puede pasar estructuras para poder trabajar
	  con colecciones de datos de forma mas facil.
	- Son utilizadas las estructuras en las funciones para contener grandes
	  cantidades de datos. Se considera buena practica que la funcion no reciba
	  mas de 2 argumentos
#+BEGIN_SRC C
	struct Family {
	  char name[20];
	  char father[20];
	  char mother[20];
	  int age;
	}

  _Bool siblings(struct Family member1, struct Family member2){

	if(strcmp(member1.mother,member2.mother) == 0)
		return 1;
	else
		return 0;

  }
#+END_SRC

	PUNTEROS A ESTRUCTURAS COMO PUNTEROS A FUNCIONES
	- Se puede usar un puntero a estructura como argumento de una funcion.
	  - Toma un poco de tiempo copiar una estructura larga como argumento,
		ademas de lo que se requiere de memoria para copiar la estrutura.
	  - Los punteros a estructuras evitan el consumo de memoria al copiar en la
		memoria en la funcion.

#+BEGIN_SRC C
	
  _Bool siblings(struct Family *pmember1, struct Family *pmember2){

	if(strcmp(pmember1->mother,pmember2->mother) == 0)
		return 1;
	else
		return 0;

  }
#+END_SRC

	- Se puede usar un modificador de constantes para que no se premita
	  la modificacion de los miembros de las estructuras o la direccion
	  a la que apunta la estructura.

	- En el siguiente ejemplo en sibling2 el operador de indirección en frente
	  de la palabra *const* .
	  - No esta frente de los nombre de parametros.
	  - No se puede modificar la direccion almacenada en los punteros.
	  - En esta caso especifico son los punteros los que estan portegidos aqui
		no las estrutura a las que se apunta. 
		
#+BEGIN_SRC C

   // Constantes a estructura, no permite cambiar los valores de la estructrura
   _Bool siblings( Family const *pmember1, Family const *pmember2){

		 if(strcmp(pmember1->mother,pmember2->mother) == 0)
			 return 1;
		 else
			 return 0;

   }

   // Constantes a puntero de estructura, no permite cambiar las direccion a la que apunta
   // la estrutura.
   _Bool siblings2( Family *const pmember1, Family *const pmember2){

		 if(strcmp(pmember1->mother,pmember2->mother) == 0)
			 return 1;
		 else
			 return 0;

   }

#+END_SRC

	RETORNANDO UNA ESTRUCTURA DE UNA FUNCION
	- En la funciones los prototipos deben retornar el valor indicado de forma normal
	- A menudo es mas conveniente retornar un puntero a una estructura.
	- Cuando retorna un puntero a una estrutura, se debe crear en el cumulo(HEAP) 

#+BEGIN_SRC C
  struct Date my_fun(void);   // Este es el prototipo de una funcion donde se retorna
							  // una estructura de tipo Date
#+END_SRC

#+BEGIN_SRC C
  #define FUNDLEN  300
	struct funds {
		char bank[FUNDLEN];
		double backfund;
		char save[FUNDLEN];
		double savefund;
	}
		double sum(struct funds moolah){
		return moolah.backfund + moolah.savefund;
	}

	int main(void) {
		struct funds stan = {
			"Garlic-Melon Bank",
			 4032.27,
			"Other bank Bank",
			 8543.94,
		}
		printf("Stan has a total of $%.2f.\n",sum(stan));	
	}


#+END_SRC

	RECORDATORIO

	- Se deben pasar punteros a estructuras en vez de estruturas en si
	- Pasar punteros a estructuras ofrece menos proteccion a los datos.
	  - Algunas operaciones no a realizar dentro de la funcion podria afectar
		de forma inadvertida a la estructura que se le pasa por argumento.

    - Aunque trabajar con parametros dentro de las funciones es mas pesado para el
	  sistema en cuestion de recursos, ofrece ventaja a tomar en cuenta.
	  - Cuando se pasa estructuras a la función como argumento se trabaja con una copia
		de la información general que es mas seguro que trabajar con la informacion original.
	  - El estilo de programación tiende a ser mas claro.
	- Pasar estructuras como argumento tiene como desventajas:
	  - Viejas implementaciones del codigo no pueden manejar el codigo.
	  - Perdida de tiempo y espacio.
	  - Es especialmente inutil pasar grandes estruturas a funciones que usan uno o dos
		parametros.
	  MIN 10:20
	- Los programadores usan punteros a estructuras en funciones por razón de eficiencia.
	  y usan const cuando es necesario.
	- Pasar estructuras por valor es la mas utilizado pora estructuras que son pequeñas.

*** DONE Desafio delarar e inicializar estructuras(Challenge Declaring and initializing a structure)
	CLOSED: [2023-11-10 vie. 15:18]
	- Escriba un programa que inicialize una estructura que imprima su contenido
	  - Cree una estrutura de tipo empleado con 3 miembros
	  - name (char array)
	  - hireDate(int)
	  - salary(float)

	- Se debe crear una instancias de empleado que contenga una datos de un empleado creado
	  localmente.
	- Se debe leer un segundo empleado por la consola y almacenarlo en otra estructura.
	- Imprimir la el contenido de cada estructura. 
#+BEGIN_SRC C Mi solucion
  #include <stdio.h>
  #include <stdlib.h>

  #define MAX_CHAR 100

  typedef struct employee employee;

  struct employee{
	  char *name; 
	  int hireDate;
	  float salary;
  };

  // Si uso un typedef en la declaracion de la estructura no tengo que
  // pasarle la declaracion de struct como paramnetro de funcion.
  // ejemplo: 
  // void print_employee_data(char *descripcion,struct employee const *emp)
  void print_employee_data(char *descripcion, employee const *emp){
	  printf("%s nombre: %s, su anio de contrato es: %d, y su salario es de: %f pesos. \n",descripcion,emp->name,emp->hireDate,emp->salary);
  }


  int main()
  {

	  employee emp = {.name = "Alejandro",.hireDate = 2022, .salary = 5550};
	  employee emp2; 

	  emp2.name = (char *)malloc(sizeof(char) * MAX_CHAR);
	  emp2.hireDate = 0;
	  emp2.salary = 0.0;

	  printf("Describa el nombre del empleado: \n");   
	  scanf("%[^\n]",emp2.name);		 
	  printf("Describa el anio de contratacion del empleado: \n");   
	  scanf("%d",&emp2.hireDate);		 
	  printf("Describa el salario del empleado: \n");   
	  scanf("%f",&emp2.salary);		 


	  print_employee_data("El primer trabajador tiene como ",&emp);
	  print_employee_data("El segundo trabajador tiene como ",&emp2);


	  return 0;
  }

#+END_SRC
*** DONE Punteros a estructuras y funciones (Structure Pointers and functions)
CLOSED: [2023-11-26 dom 11:10]
	- Escriba un programa en C que cree un puntero de estrutura y se le pase a funciones.
	- Crear una estructura de objetos nombrada con los siguientes miembros
	  - itemName (pointer)  
	  - quantity (int)  
	  - precio (pointer)  
	  - cantidad (float) (cantidad * precio)
    - Cree una funcion de nombre readItem que tome el puntero a una estructura
	  de tipo puntero (item) como parametro
	  - Esta funcion debera leer del usuario un nombre de producto, precio y una cantidad
	  - El contenido de la funcion se debera almacenar en la estructura pasada a la funcion.

	- Cree una funcion de nombre printItem que tome como parametro el puntero de una estructura
	  de tipo objeto.
		- La funcion imprime el contenido del parametro que se le paso
	- La funcion main debera declara un objeto y un puntero al objeto
	  - Se necesita almacenar memoria para el puntero itemName.
	  - El puntero objeto(item) se debe pasar a ambas funciones tanto de lectura como escritura.

	#+BEGIN_SRC C
	#include <stdio.h>
	#include <stdlib.h>

	#define MAX_CHAR 100

	typedef struct Item Item;

	struct Item{
		char *itemName; 
		int quantity;
		float price;
		float amount;   // Es (cantidad * precio)
	};


	void readItem(struct Item  *const itm){
		printf("Describa el nombre del empleado: \n");   
		scanf("%[^\n]",itm->itemName);		 
		printf("Describa el anio de contratacion del empleado: \n");   
		scanf("%f",&(itm->price));		 
		printf("Describa el salario del empleado: \n");   
		scanf("%d",&(itm->quantity));		 
	}


	int main(){
		return 0;
	}


	#+END_SRC
#+BEGIN_SRC C


  #include <stdio.h>
  #include <stdlib.h>

  #define MAX_CHAR 100

  struct Item{
	char *itemName; 
	int quantity;
	float price;
	float amount;   // Es (cantidad * precio)

  };


  void free_elm(void *elm){
	  free(elm);
	  elm = NULL;
  }

  void readItem(struct Item  *const itm){
		printf("Describa el nombre del objeto: \n");   
		itm->itemName = (char *) malloc(sizeof(char) * 100);
		scanf("%[^\n]",itm->itemName);		 
		printf("Describa el precio del objetos: \n");   
		scanf("%f",&(itm->price));		 
		printf("Describa la cantidad del objeto: \n");   
		scanf("%d",&(itm->quantity));		 
  }

  void printItem(struct Item *const itm){
	  printf("El nombre del empleado es %s \n",itm->itemName);   
	  printf("La cantidad de objetos que se le paso es de  %d: \n",itm->quantity);   
	  printf("El precio de los objetos que se les paso es de  %f: \n",itm->price);   
	  printf("El total entre precio y valor de los objetos es de %f: \n",(float)(itm->quantity * itm->price));   
  }



  int main(){
	  struct Item *item = (struct Item *)malloc(sizeof(struct Item));
	  readItem(item);
	  printItem(item);

	  printf("La direccion de memoria antes de liberar a Item es %p: \n",&item->itemName);

	  free(item->itemName);
	  item->itemName= NULL;

	
	  free(item);
	  item = NULL;

	  printf("La direccion de memoria depues de liberar a Item es %p: \n",&item->itemName);
	  printf("El valor de itemName es : %s",item->itemName);


	  return 0;
   }


#+END_SRC

** TODO 14. Files input and Output [0/8]

  -- NO ESTA BIEN RESUMIDO A PARTIR DE AQUI
  -- REACER TODO EL CAPITULO
  -- ANTES DE CONTINUAR TERMINAR LOS CAPITULOS ANTERIORES (capitulo del desafio de tic tac toe)

*** DONE Resumen (Overview)
	CLOSED: [2023-11-14 mar. 11:14]
	- Los programas profecionales requieren mucha mas informacion de la que cabe en la
	  memoria.
	  - Tambien depende de la habilidad de procesar la informacion que se
		encuentra en la memoria.
	- C provee mucha funciones para la lectura y escritura dispositivos externos
	  - El dispositivo externo que accedera a la información es tipicamente un disco duro interno.
	  - La biblioteca accedera a cualquier con cualquier disco de almacenamiento.
	  - La memoria hasta ahora era volatil donde el usuario tenia que insertarla manualmente
	    lo cual limitaba el uso del programa.

	- Los sistemas necesitan almacener la información *no volatil* y usualmente se usa
	  la biblioteca estandar *stdio.h* para esto.
	- C ve los archivos como secuencia de bytes continuos.
	  - Cada byte se lee individualmente.
	  - Esto corresponde a la estructura de ficheros de UNIX.
    FICHEROS
    - Los ficheros tienen tres elementos de position.
	  - Al principio
	  - En la posicion actual.
	  - Al final del archivo.
	- En la posicion actual es donde se realiza la accion sobre los ficheros (lectura y escritura)
	  Se puede mover la posicion actual a cualquier punto del fichero(incluso en el final).

	FICHEROS DE TEXTO Y BINARIOS

	TEXTO
	- Hay dos formas de escribir un fichero a una cadena que representa un fichero.
	  - Texto
	  - Binario
	- Los datos estan ecritos como secuencia de caracteres organizados como lineas
	  - Cada linea finaliza con una nueva linea(*'\n').*  

	BINARIO
	- Los datos en binario son escrito en una serie de bytes, de forma exacta a como
	  aparece en memoria.
	  - Datos de imagenes
	  - Codificacion de musica
	- Esta forma de almacenar no es legible para el usuario normal y se deben usar programas
	  para ver la informacion de estos ficheros.

	- Se puede escribir cualquier datos que se desee en un archivo.
	  - Una vez que el fichero ha sido escrito solo consiste en una serie de bytes.

    - Se debe entender el formato del fichero antes de leerlo
	  un fichero puede poseer:
	  - Una sequencia de 12 bytes en un archivo binario puede ser 12 caracteres,
		12 8-bit signed interger, 12 8 bit unsigned integer, ect.
	  - En modo binario, cada byte del archivo es accesible.

	STREAMS (Flujo de Datos)
	- Un fichero en C abre automaticamente 3 archivos en tu (behalf)
	  - Entrada estandar:  La entrada tipica de tu sistema, usualmente el teclado.
	  - Salida estandar: Usualmente el monitor.
	  - Errores estandar: Usualmente el monitor.

	- La entrada estandar es el archivo que es leido por getchar() y scanf().

	- La salida estandar es usada por putchar(), puts(),y printf()
	  La redireccion causa que otros archivos sean reconocidos como salida o entrada
	  estandar.
	- El objetivo de la salida estandar de errores en un fichero es proveer un lugar
	  donde enviar mensajes de errores.
	- Un _stream_ es una representacion abstracta de cualquier fuente externo o destino
	  para los datos.
	  - Los teclados, lineas de comandos en tu monitor y archivos en el disco son ejemplos
		de como se puede trabajar con *streams*.
	- La biblioteca de C tiene funciones de lectura y escritura, desde y hacia los (data streams)
	  - Se puede usar la misma funcion de entrada y salida para leer y escribir en cualquier
		dispositivo que es mapeado a una *stream*.
*** DONE Accediendo a ficheros (accessing files)
	CLOSED: [2023-11-20 lun. 14:15]

	ACCESO A UN FICHERO
	- Los archivos en discos tiene un nombre y reglas determinadas por el Sitema operativo(SO).
	  - Se debe ajustar los nombres depediendo de que sistema operativo este corriendo.
	- Un programa referencia a un programa a travez de un puntero
	  MIN 0:52
	  
    - Para leer de un fichero abierto se usa la funcion fgetc()
    - La funcion recibe el puntero de el fichero y retorna un int 
#+BEGIN_SRC C
		//Lee caracter a caracter del fichero pfile  
		int mchar = fgetc(pfile);
#+END_SRC 

- Para leer un caracter en un fichero se usa la funcion fgetc. Esta funcion lee caracter a caracter.

#+BEGIN_SRC C
 #include <stdio.h>

	 FILE *fp = NULL;
	 int mchar = fgetc(fp);

	//Funcion para empezar colocar el puntero al principio del fichero;
	rewind(fp);
#+END_SRC
- Se puede tantas veces el fichero como se quiera usando la funcion rewind
- Ejemplo de lectura con fgetc 
#+BEGIN_SRC C
	#include <stdio.h>

	int main(){
		FILE *fp;
		int c;
		fp = fopen("myfichero.txt");

		if(fp == NULL){
			printf("%s","Error al abrir el fichero");
			return -1;
		}
		//Falta el resto que esta en el video de lectura de ficheros del curso de c

		fclose(fp);
		fp = NULL;
		return 0;
	}
#+END_SRC 

- Para leer un fichero en todos los datos de un fichero caracter a caracter se debe un funcion que lea todo el archivo
#+BEGIN_SRC C
FILE *fp;
int c = 0;

fp = fopen("text_file.txt","r");

if(!fp){
	printf("Hay problemas al abrir el archivo");
	return (-1);
}
//Para leer un solo caracter 
while( (c = fgetc(fp)) != EOF )
	printf("%c",c);

fclose(fp);
fp = NULL;
return (0);
#+END_SRC

- Otra forma de leer en un fichero es fgets pero esta funcion solo lee el limite que se le pasa como parametro 
- char * fgets(char * str, int nchars, FILE * stream)
- La lee la cadena en el area de memoria
 1. La funcion lee y almacena en memoria  * str, desde un archivo especificado por el tipo FILE , con limite de nchars.
 2. Si un carater de nueva linea es leido se almacena en la cadena.
 3. Un  caracter de fin de cadena '\\0' se adicionara al final de la linea.
 4. Si no hay errores con la funcion fgets esta retorna el puntero con la variable  str que se le pasÃ³.

#+BEGIN_SRC C
	#include <stdio.h>
	#include <stdlib.h>

	int main()
	{
	FILE *fp;
	int len = 21;
	char *myname = malloc(sizeof(char) * len);

	fp = fopen("test.txt", "r");

	if( fgets(myname, len, fp) != NULL) 

	for(int i = 0; i < len;i++){
		//if(myname[i] == '\0')
		//break;

		if(myname[i] == '\0')
		printf("el signo es '\\0'");
		printf("%c ,%d \n",myname[i],i + 1);

	}

	free(myname);
	myname = NULL;

	fclose(fp);
	fp = NULL;

	return 0;
	}
#+END_SRC


	- Los ficheros en disco tienen un nombre y reglas para nombrar archivos segun el SO
	- Un programa referencia a un archivo atravez de un puntero
	  (o puntero de flujo (streams) que puede funcionar en mas de un archivo a la vez)
	  - Se asocia un puntero de archivo con un archivo programado cuando corre el programa.
	  - Los punteros pueden ser reusados para apuntar a diferentes archivos a diferentes ocaciones.
    - Un puntero de archivo apunta a una estructura de tipo *FILE* que representa un cadena de flujo (stream).
	  - La cadena de flujo contiene la siguiente informacion del archivo:
		- Donde quieres leer o actualizar el archivo
	    - La direccion del buffer en memoria que sera usada para datos
		- Un puntero de la posicion actual en el archivo para la proxima operacion.
	  - Las operaciones descritas son realizadas via input/output

    ACCEDIENDO A UN ARCHIVOS
	- Si quieres usar varios archivos simultaneamente en el programa, se necesitan
	  punteros independientes por cada archivos.
	  - Hay un numero maximo de archivos definido que se pueden abrir a la vez
	  - EL numero de maximo de archivos a abrir esta definido con la variable *FOPEN_MAX* en *<stdio.h>*.

	ABRIENDO UN FICHERO
	- Se puede asociar un nombre de fichero externo con un puntero de fichero a travez de un proceso
	  referido como apertura de fichero
	  - Esta operacion se hace via la funcion *fopen()*
	  - La funcion fopen() esta definida en stdio.h	y retorna un fichero para un
		archivo externo especifico.
#+BEGIN_SRC C
	FILE *fopen(const char * restrict name,const char* restrict mode); 
#+END_SRC

	- En el ejemplo anterior el primer argumento de la funcion es un puntero
	  a string el cual es el nombre del fichero a procesar.
	- Se puede especificar el nombre de explicitamente o usar un puntero a char
	  que contenga la direccion de la cadena de caracteres que se definio con el
	  nombre del archivo
	- Se puede obtener el archivo atravez de linea de comandos como entradas de los usuarios
	  o definir una constante en el programa.
	 
    - El segundo argumento de fopen() es una cadena de caracteres que representa el modo apertura
	  del archivo.
	  - Este modo especifica que se desea hacer en el fichero
	  - La especificacion del modo de apertura de cadena de caracteres es una cadena de un caracter
		con doble comillas.
	- Asumiendo que la llamada a la funcion fue exitosa la funcion retorna un puntero de tipo FILE *.
	  que se puede usar para referenciar al fichero en futuras llamadas de input/output usadas en otras
	  funciones de la biblioteca.
	- Si el fichero no se pudo abrir con *fopen()* retorna NULL.
    - Si solo se provee a file name sin ninguna ruta fopen() buscara en el directorio actual.
	    
	MODOS DE APERTURA DE FICHERO QUE SE APLICAN A ARCHIVO DE TEXTO

	|------+---------------------------------------------------------|
	| Modo | Decripcion                                              |
	|------+---------------------------------------------------------|
	| "w"  | Abre el fichero para operaciones de                     |
	|      | escritura. si el archivo existe el contenido actual     |
	|      | es descartado.                                          |
	|------+---------------------------------------------------------|
	| "a"  | Abre el fichero para operaciones de                     |
	|      | adicion. Todas la adiciones se hacen al final del       |
	|      | fichero.                                                |
	|------+---------------------------------------------------------|
	| "r"  | Abre el fichero para operaciones de lectura.            |
	|------+---------------------------------------------------------|
	| "w+" | Abre el fichero para operaciones de actuializacion      |
	|      | (lectura y escritura), primero truncando el archivo     |
	|      | a zero longitud si existe o crea el archivo en caso     |
	|      | contrario.                                              |
	|------+---------------------------------------------------------|
	| "a+" | Abre el fichero para operaciones de actuializacion      |
	|      | (lectura y escritura), adicionando al final del archivo |
	|      | o creando uno si no existe.                             |
	|------+---------------------------------------------------------|
	| "r+" | Abre un archivo para actualizar (lectura y escritura)   |
	|------+---------------------------------------------------------|

#+BEGIN_SRC C
    FILE *pfile = NULL;
    char *filename = "myfile.txt";
    pfile = fopen(filename,"w");
    if(pfile == NULL){ //Esto es = a !pfile
        printf("Failed to open %s\n",filename);
    else
        printf("File %s opened\n",filename);
    
#+END_SRC

	- Al abrir un fichero para escribir la posicion inicial de puntero sera para escribir
	  y estara colocado en la posicion 0, principio del fichero.
	- Cualquier informcion que previamente haya existido en el fichero se perdera
	  por cualquier operacion de escritura.



    - Se puede renombrar un archivo con la funcion rename()
    - La funcion retornara 0 si se cambio el nombre correctamente, no zero si no se cambio el nombre
    - OJO Si el fichero esta abierto la funcion fallara.

#+BEGIN_SRC C
int rename(const char *oldname,const char *newname);

if(rename("C:\\temp\\myfile.txt","C:\\temp\\myfile_copy.txt"))
    printf("Failed to rename the file");

printf("File to rename the successfully.");
#+END_SRC

    - Una vez el fichero abierto debe cerrarse para evitar fugas de memoria ya que la funcion fopen() devuelve un puntero creado dinamicamente
    - El fichero se cierra con la funcion fclose() la cual acepta un puntero como argumento
    - Si falla retorna End of File (EOF) o (int)
    - Si cierra correctamente retorna 0
    - Se recomienda cerrar el fichero para evitar la perdida de datos
	  
#+BEGIN_SRC C
    //Siguiendo con el ejemplo anterior 
    fclose(pfile);
    pfile = NULL;

#+END_SRC

    - Para borrar un fichero se usa la funcion remove()
    - Se debe comprobar las operaciones con ficheros que se van a borrar y chequer que el fichero esta cerrado.
#+BEGIN_SRC C

    remove("myfile.txt");

#+END_SRC

*** TODO leyendo de un archivo (reading for a file)
	VER VIDEO DESDE EL PRINCIPIO  
    - Para leer de un fichero abierto se usa la funcion fgetc()
    - La funcion recibe el puntero de el fichero y retorna un int 
#+BEGIN_SRC C
//Lee caracter a caracter del fichero pfile  
	int mchar = fgetc(pfile);
#+END_SRC 

- Para leer un caracter en un fichero se usa la funcion fgetc. Esta funcion lee caracter a caracter.
- La variable mchar declarada anteriormente es de tipo int ya que EOF sera retornado si alcanza el
  final del archivo.
- La funcion getc(), el cual es equivalente a fgetc, tambien esta disponible, esta tambien requiere un
  un argumento de tipo FILE* y retorne el caracter como tipo *int*.
  - la funcion es virtualmente identica a fgetc()
  - la unica diferencia diferencia entre getc y fgetc es que la primera se implementa como macro y la
	segunda es una funcion.
  - Puedes leer el contesto de nuevo cuando es necesario
	TRADUCIR LA SIGUIENTE ORACION
	_the rewind() function positions the file that is specified by the file pointer argument at the beginning_

#+BEGIN_SRC C
	rewind(pfile);
  
#+END_SRC
  
#+BEGIN_SRC C
  	  #include <stdio.h>

	  FILE *fp = NULL;
	  int mchar = fgetc(fp);

	 //Funcion para empezar colocar el puntero al principio del fichero;
	 rewind(fp);

#+END_SRC

- Se puede tantas veces el fichero como se quiera usando la funcion rewind
- Ejemplo de lectura con fgetc 

#+BEGIN_SRC C

  #include <stdio.h>

  int main(){
	  FILE *fp;
	  int c;
	  fp = fopen("myfichero.txt");

	  if(fp == NULL){
		  printf("%s","Error al abrir el fichero");
		  return -1;
	  }
	  //Falta el resto que esta en el video de lectura de ficheros del curso de c

	  fclose(fp);
	  fp = NULL;
	  return 0;
  }

#+END_SRC 

- Para leer un fichero en todos los datos de un fichero caracter a caracter se debe un funcion que lea todo el archivo

#+BEGIN_SRC C Lectura de un fichero caracter a caracter
  FILE *fp;
  int c = 0;

  fp = fopen("text_file.txt","r");

  if(!fp){
	  printf("Hay problemas al abrir el archivo");
	  return (-1);
  }
  //Para leer un solo caracter 
  while( (c = fgetc(fp)) != EOF )
	  printf("%c",c);

  fclose(fp);
  fp = NULL;
  return (0);

#+END_SRC

- Otra forma de leer en un fichero es fgets pero esta funcion solo lee el limite que se le pasa como parametro 
- char * fgets(char * str, int nchars, FILE * stream)
- La lee la cadena en el area de memoria
 1. La funcion lee y almacena en memoria  * str, desde un archivo especificado por el tipo FILE , con limite de nchars.
 2. Si un carater de nueva linea es leido se almacena en la cadena.
 3. Un  caracter de fin de cadena '\\0' se adicionara al final de la linea.
 4. Si no hay errores con la funcion fgets esta retorna el puntero con la variable  str que se le pasÃ³.

#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>

int main()
{
  FILE *fp;
  int len = 21;
  char *myname = malloc(sizeof(char) * len);

  fp = fopen("test.txt", "r");

  if( fgets(myname, len, fp) != NULL) 
	
  for(int i = 0; i < len;i++){
    //if(myname[i] == '\0')
    //break;

    if(myname[i] == '\0')
      printf("el signo es '\\0'");
      printf("%c ,%d \n",myname[i],i + 1);
		
  }

  free(myname);
  myname = NULL;

  fclose(fp);
  fp = NULL;
  
  return 0;
}
#+END_SRC

*** TODO Escribiendo a un archivo (writing to a file)
*** TODO Encontrando tu posiocion en un archivo (finding your position in a file)
*** TODO Encuentra el numero de lineas en un archivo (find the number of lines in a file)
*** TODO Convertir caracteres de un archivo a mayuscula (Convert character in a file to uppercase)
*** TODO Imprimir el contenido de un archivo en orden inverso (Print the contents of a file in reverse order)
** TODO 15. The standart C library [0/4]
   - [ ] Standart header files
   - [ ] Various Functions
   - [ ] Math Functions
   - [ ] Utility Functions
* Lenguage de programacion C Conceptos Avanzados
